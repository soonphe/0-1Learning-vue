(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{241:function(e,t,n){e.exports=n.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(e,t,n){e.exports=n.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(e,t,n){e.exports=n.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},328:function(e,t,n){"use strict";n.r(t);var a=n(14),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_0-1learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[e._v("#")]),e._v(" 0-1Learning")]),e._v(" "),t("p",[t("img",{attrs:{src:n(241),alt:"alt text",title:"公众号"}}),e._v(" "),t("img",{attrs:{src:n(242),alt:"alt text",title:"学习"}}),e._v(" "),t("img",{attrs:{src:n(243),alt:"alt text",title:"微信"}})]),e._v(" "),t("h2",{attrs:{id:"广播接收器broadcast-receiver"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广播接收器broadcast-receiver"}},[e._v("#")]),e._v(" 广播接收器broadcast receiver")]),e._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("什么是广播：来自村口的广播了一句下雨了，回家收衣服。身在地里干活的你，收到消息，立刻回家，收好了衣服，关好了窗户。\n\n广播接收器用于响应来自其他应用程序或者系统的广播消息。比如开机广播、短信广播、下载广播，不断能监听到这些信息，还能响应响应的信息。\n")])])]),t("h3",{attrs:{id:"广播机制简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广播机制简介"}},[e._v("#")]),e._v(" 广播机制简介")]),e._v(" "),t("p",[e._v("标准广播（Normal broadcasts）是一种完全异步执行的广播，在广播发出之后，所有的\n广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。")]),e._v(" "),t("p",[e._v("有序广播（Ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻\n只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递")]),e._v(" "),t("h3",{attrs:{id:"广播接收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广播接收器"}},[e._v("#")]),e._v(" 广播接收器")]),e._v(" "),t("p",[e._v("Broadcast Receiver\nandroid 广播分为两个角色：广播发送者、广播接收者\nandroid 广播：\n1），用于不同组件间的通信（含：应用内/不同应用之间）\n2），用于多线程通信\n3），与android系统的通信")]),e._v(" "),t("h3",{attrs:{id:"自定义广播接收者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义广播接收者"}},[e._v("#")]),e._v(" 自定义广播接收者")]),e._v(" "),t("p",[e._v("继承BroadcastReceive 基类，重写抽象方法onReceive()方法\n1.广播接收器收到相应广播后，会自动调用onReceive(） 方法\n2.一般情况下，onReceive方法会会涉及与其他组件之间的交互，如 发送Notiotification，启动server等\n3.默认情况下，广播接收器运行在UI线程，因此，onReceive方法不能执行耗时操作，否则将导致ANR\n4.最后要记得，动态注册的广播接收器一定都要取消注册才行，这里我们是在onDestroy()方法中通过调用unregisterReceiver()方法来实现的")]),e._v(" "),t("h3",{attrs:{id:"广播接收器注册"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广播接收器注册"}},[e._v("#")]),e._v(" 广播接收器注册")]),e._v(" "),t("p",[e._v("注册的方式有两种：静态注册、动态注册")]),e._v(" "),t("h4",{attrs:{id:"静态注册"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态注册"}},[e._v("#")]),e._v(" 静态注册")]),e._v(" "),t("p",[e._v("注册方式：在AndroidManifest.xml 里通过<receive 标签声明\n属性说明")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<receiver\n\tandroid:enable="true"/"false"\n\t//此broadcastReceiver 是否接受其他应用发出的广播\n\t//默认值时由receiver 中d有无inter-filter决定，如果有，默认true，否则默认false\n\tandroid:exported="true"/"false"\n\tandroid:icon="drawable resource"\n\tandroid:label="string resource"\n\t//继承BroadcastReceiver子类的类名\n    android:name=".mBroadcastReceiver"\n//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；\n    android:permission="string"\n//BroadcastReceiver运行所处的进程\n//默认为app的进程，可以指定独立的进程\n//注：Android四大基本组件都可以通过此属性指定自己的独立进程\n    android:process="string" >\n\n//用于指定此广播接收器将接收的广播类型\n//本示例中给出的是用于接收网络状态改变时发出的广播\n <intent-filter>\n\t<action android:name="android.net.conn.CONNECTIVITY_CHANGE" />\n </intent-filter>\n </receiver>\n\n注册示例：\n<receiver \n    //此广播接收者类是mBroadcastReceiver\n    android:name=".mBroadcastReceiver" >\n    //用于接收网络状态改变时发出的广播\n    <intent-filter>\n        <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />\n    </intent-filter>\n</receiver>\n')])])]),t("p",[e._v("当此APP首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中。")]),e._v(" "),t("h4",{attrs:{id:"动态注册"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态注册"}},[e._v("#")]),e._v(" 动态注册")]),e._v(" "),t("p",[e._v("注册方式：在代码中调用Context.registerReceiver() 方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("具体代码如下：\n\t// 1. 实例化BroadcastReceiver子类 &  IntentFilter\n     mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver();\n     IntentFilter intentFilter = new IntentFilter();\n\n    // 2. 设置接收广播的类型\n    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);\n\n    // 3. 动态注册：调用Context的registerReceiver（）方法\n     registerReceiver(mBroadcastReceiver, intentFilter);\n\n")])])]),t("p",[e._v("//动态注册广播后，需要在相应位置记得销毁广播\nunregisterReceiver(mBroadcastReceiver);")]),e._v(" "),t("h3",{attrs:{id:"动态广播应该何时注册和注销"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态广播应该何时注册和注销"}},[e._v("#")]),e._v(" 动态广播应该何时注册和注销")]),e._v(" "),t("p",[e._v("动态广播最好在onResume中注册， onPause注销\n原因：\n1，对于动态广播，有注册必然得有注销，否则会导致内存泄漏\n2，onPause在App死亡前一定会被执行，从而保证app死亡前一定会被注销，从而防止内存泄漏")]),e._v(" "),t("h3",{attrs:{id:"两种注册方式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两种注册方式的区别"}},[e._v("#")]),e._v(" 两种注册方式的区别")]),e._v(" "),t("p",[e._v("广播的发送 = 广播发送者 将此广播的意图（intent）通过 sendBroasdcast() 方法发送出去\n广播的类型：普通广播 系统广播 有序广播 粘性广播 App 应用内广播")]),e._v(" "),t("p",[e._v("特别注意：\n对于不同注册方式的广播接收器回调OnReceive（Context context，Intent intent）中的context返回值是不一样的：")]),e._v(" "),t("p",[e._v("对于静态注册（全局+应用内广播），回调onReceive(context,intent)中的context返回值是：ReceiverRestrictedContext；")]),e._v(" "),t("p",[e._v("对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；")]),e._v(" "),t("p",[e._v("对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context,intent)中的context返回值是：Application Context。")]),e._v(" "),t("p",[e._v("对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context,intent)中的context返回值是：Activity Context；")]),e._v(" "),t("h3",{attrs:{id:"发送广播"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送广播"}},[e._v("#")]),e._v(" 发送广播")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST");\nsendBroadcast(intent);  //发送标准广播,这个是context中的方法\n\nsendOrderedBroadcast(intent, null); // 发送有序广播\n')])])]),t("h3",{attrs:{id:"使用本地广播-localbroadcastmanager"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用本地广播-localbroadcastmanager"}},[e._v("#")]),e._v(" 使用本地广播——LocalBroadcastManager")]),e._v(" "),t("p",[e._v("前面我们发送和接收的广播全部都是属于系统全局广播，即发出的广播可以被其他任何\n的任何应用程序接收到，并且我们也可以接收来自于其他任何应用程序的广播。这样就很容\n易会引起安全性的问题，比如说我们发送的一些携带关键性数据的广播有可能被其他的应用\n程序截获，或者其他的程序不停地向我们的广播接收器里发送各种垃圾广播。\n为了能够简单地解决广播的安全性问题，Android 引入了一套本地广播机制，使用这个\n机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用\n程序发出的广播，这样所有的安全性问题就都不存在了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('localBroadcastManager = LocalBroadcastManager.getInstance(this);// 获取实例\nButton button = (Button) findViewById(R.id.button);\nbutton.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");\n        localBroadcastManager.sendBroadcast(intent); // 发送本地广播\n    }\n});\nintentFilter = new IntentFilter();\nintentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");\nlocalReceiver = new LocalReceiver();\nlocalBroadcastManager.registerReceiver(localReceiver, intentFilter);    // 注册本地广播监听器\n\n\nclass LocalReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context, "received local broadcast",\n        Toast.LENGTH_SHORT).show();\n    }\n}\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);