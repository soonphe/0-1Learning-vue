(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{241:function(a,s,t){a.exports=t.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(a,s,t){a.exports=t.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(a,s,t){a.exports=t.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},369:function(a,s,t){"use strict";t.r(s);var e=t(14),n=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_0-1learning"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[a._v("#")]),a._v(" 0-1Learning")]),a._v(" "),s("p",[s("img",{attrs:{src:t(241),alt:"alt text",title:"公众号"}}),a._v(" "),s("img",{attrs:{src:t(242),alt:"alt text",title:"学习"}}),a._v(" "),s("img",{attrs:{src:t(243),alt:"alt text",title:"微信"}})]),a._v(" "),s("h2",{attrs:{id:"java-overview总述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-overview总述"}},[a._v("#")]),a._v(" java-overview总述")]),a._v(" "),s("h3",{attrs:{id:"jdk包结构-linux-1-8版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk包结构-linux-1-8版本"}},[a._v("#")]),a._v(" jdk包结构（linux 1.8版本）")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("bin目录")]),a._v(": JDK开发工具的可执行文件")]),a._v(" "),s("li",[s("strong",[a._v("lib目录")]),a._v(": 开发工具使用的归档包文件")]),a._v(" "),s("li",[s("strong",[a._v("jre")]),a._v(":  Java 运行时环境的根目录，包含Java虚拟机，运行时的类包和Java应用启动器， 但不包含开发环境中的开发工具")]),a._v(" "),s("li",[a._v("demo: 含有源代码的程序示例")]),a._v(" "),s("li",[a._v("include: 包含C语言头文件,支持Java本地接口与Java虚拟机调试程序接口的本地编程技术")])]),a._v(" "),s("h3",{attrs:{id:"jdk中jar包结构功能树-linux-1-8版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk中jar包结构功能树-linux-1-8版本"}},[a._v("#")]),a._v(" jdk中jar包结构功能树（linux 1.8版本）")]),a._v(" "),s("ul",[s("li",[a._v("rt.jar：Java基础类库，也就是Java doc里面看到的所有的类的class文件。")]),a._v(" "),s("li",[a._v("tools.jar：是系统用来编译一个类的时候用到的，即执行javac的时候用到。")]),a._v(" "),s("li",[a._v("dt.jar：dt.jar是关于运行环境的类库，主要是swing包。")]),a._v(" "),s("li",[a._v("i18n.jar: 字符转换类及其它与国际化和本地化有关的类。")])]),a._v(" "),s("h3",{attrs:{id:"jdk内置命令行工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk内置命令行工具"}},[a._v("#")]),a._v(" JDK内置命令行工具")]),a._v(" "),s("p",[a._v("JDK 内置了许多命令行工具，它们可用来获取目标 JVM 不同方面、不同层次的信息。")]),a._v(" "),s("ul",[s("li",[a._v("jinfo - 用于实时查看和调整目标 JVM 的各项参数。")]),a._v(" "),s("li",[a._v("jstack - 用于获取目标 Java 进程内的线程堆栈信息，可用来检测死锁、定位死循环等。")]),a._v(" "),s("li",[a._v("jmap - 用于获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。")]),a._v(" "),s("li",[a._v("jstat - 一款轻量级多功能监控工具，可用于获取目标 Java 进程的类加载、JIT 编译、垃圾收集、内存使用等信息。")]),a._v(" "),s("li",[a._v("jcmd - 相比 jstat 功能更为全面的工具，可用于获取目标 Java 进程的性能统计、JFR、内存使用、垃圾收集、线程堆栈、JVM 运行时间等信息。")])]),a._v(" "),s("p",[a._v("使用示例：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("jstat -gc <pid>：显示垃圾收集信息，包括堆内存的使用情况。\nS0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   \n26176.0 26176.0  0.0   21463.1 209792.0 76414.7   786432.0   36711.4   86504.0 81289.3 11356.0 10504.3     21    0.461   6      0.115    0.576\n\n- S0C：第一个幸存区的大小\n- S1C：第二个幸存区的大小\n- S0U：第一个幸存区的使用大小\n- S1U：第二个幸存区的使用大小\n- EC：Eden区的大小\n- EU：Eden区的使用大小（重点关注）\n- OC：老年代大小\n- OU：老年代使用大小（重点关注）\n- MC：元空间大小\n- MU：元空间使用大小\n- CCSC：压缩类空间大小\n- CCSU：压缩类空间使用大小\n- YGC：年轻代垃圾回收次数（重点关注）\n- YGCT：年轻代垃圾回收消耗时间\n- FGC：老年代垃圾回收次数（重点关注）\n- FGCT：老年代垃圾回收消耗时间\n- GCT：垃圾回收消耗总时间\n\njmap -heap <pid>：显示堆的内存映射并输出到文件（调用失败）\n")])])]),s("h4",{attrs:{id:"jmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmap"}},[a._v("#")]),a._v(" jmap")]),a._v(" "),s("ul",[s("li",[a._v("jmap（linux下特有，也是很常用的一个命令）观察运行中的jvm物理内存的占用情况。\n参数如下："),s("br"),a._v("\n-heap：打印jvm heap的情况"),s("br"),a._v("\n-histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。"),s("br"),a._v("\n-histo：live ：同上，但是只答应存活对象的情况"),s("br"),a._v("\n-permstat：打印permanent generation heap情况")])]),a._v(" "),s("h4",{attrs:{id:"jstack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jstack"}},[a._v("#")]),a._v(" jstack")]),a._v(" "),s("ul",[s("li",[a._v("jstack（linux下特有）可以观察到jvm中当前所有线程的运行情况和线程当前状态")])]),a._v(" "),s("h4",{attrs:{id:"jconsole"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jconsole"}},[a._v("#")]),a._v(" jconsole")]),a._v(" "),s("p",[a._v("jconsole：Jconsole （Java Monitoring and Management Console），一种基于JMX的可视化监视、管理工具。\nJConsole 基本包括以下基本功能：概述、内存、线程、类、VM概要、MBean")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("内存监控\n内存页签相对于可视化的jstat 命令，用于监视受收集器管理的虚拟机内存。")])]),a._v(" "),s("li",[s("p",[a._v("线程监控\n如果上面的“内存”页签相当于可视化的jstat命令的话，“线程”页签的功能相当于可视化的jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。线程长时间停顿的主要原因主要有：等待外部资源（数据库连接、网络资源、设备资\n源等）、死循环、锁等待（活锁和死锁）")])])]),a._v(" "),s("h4",{attrs:{id:"jvisualvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvisualvm"}},[a._v("#")]),a._v(" jvisualvm")]),a._v(" "),s("p",[a._v("jvisualvm：VisualVM（All-in-One Java Troubleshooting Tool）;功能最强大的运行监视和故障处理程序")]),a._v(" "),s("ul",[s("li",[a._v("显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。")]),a._v(" "),s("li",[a._v("监视应用程序的CPU、GC、堆、方法区(1.7及以前)，元空间（JDK1.8及以后）以及线程的信息（jstat、jstack）。")]),a._v(" "),s("li",[a._v("dump以及分析堆转储快照（jmap、jhat）。")]),a._v(" "),s("li",[a._v("方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。")]),a._v(" "),s("li",[a._v("离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照")])]),a._v(" "),s("p",[a._v("平时启动jvisualvm")]),a._v(" "),s("ol",[s("li",[a._v("/usr/libexec/java_home -V")]),a._v(" "),s("li",[a._v("cd /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/bin")]),a._v(" "),s("li",[a._v("jvisualvm")])]),a._v(" "),s("h4",{attrs:{id:"jstat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jstat"}},[a._v("#")]),a._v(" jstat")]),a._v(" "),s("ul",[s("li",[a._v("jstat最后要重点介绍下这个命令。这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息\n具体参数如下：\n-class：统计class loader行为信息"),s("br"),a._v("\n-compile：统计编译行为信息"),s("br"),a._v("\n-gc：统计jdk gc时heap信息"),s("br"),a._v("\n-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况"),s("br"),a._v("\n-gccause：统计gc的情况，（同-gcutil）和引起gc的事件"),s("br"),a._v("\n-gcnew：统计gc时，新生代的情况"),s("br"),a._v("\n-gcnewcapacity：统计gc时，新生代heap容量"),s("br"),a._v("\n-gcold：统计gc时，老年区的情况"),s("br"),a._v("\n-gcoldcapacity：统计gc时，老年区heap容量"),s("br"),a._v("\n-gcpermcapacity：统计gc时，permanent区heap容量"),s("br"),a._v("\n-gcutil：统计gc时，heap情况"),s("br"),a._v("\n-printcompilation：不知道干什么的，一直没用过。")])]),a._v(" "),s("hr"),a._v(" "),s("h3",{attrs:{id:"常见问题处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见问题处理"}},[a._v("#")]),a._v(" 常见问题处理")]),a._v(" "),s("h4",{attrs:{id:"例-一次排查线上问题进行解答。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#例-一次排查线上问题进行解答。"}},[a._v("#")]),a._v(" * 例:一次排查线上问题进行解答。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("输入jps，获得进程号。\ntop -Hp pid 获取本进程中所有线程的CPU耗时性能\njstack pid命令查看当前java进程的堆栈状态\n或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。\n可以使用fastthread 堆栈定位，fastthread.io/\n")])])]),s("h4",{attrs:{id:"如果发生oom-日志很多-该如何处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果发生oom-日志很多-该如何处理"}},[a._v("#")]),a._v(" 如果发生OOM，日志很多，该如何处理")]),a._v(" "),s("p",[a._v("查看dump日志")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("java -jar \n-verbose:gc \n-XX:+PrintGCDetails \n-XX:+PrintGCTimeStamps \n-Xloggc:/usr/local/gclog/gc.log         #gc日志 \n-XX:+HeapDumpOnOutOfMemoryError         #配置在OOM时自动生成dump文件\n-XX:HeapDumpPath=/usr/local/gclog/dump.hprof    #dump存储路径\n")])])]),s("p",[a._v("如果日志过多，几十G上百G，分析起来可能也不太现实，所以可以使用dump分析：")]),a._v(" "),s("p",[a._v("java获取内存dump中的数据的几种方式：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("获取内存详情：jmap -dump:format=b,file=e.bin pid号\n这种方式可以用jvisualvm.exe进行内存分析，或者采用Eclipse Memory Analysis Tools（MAT）这个工具")])]),a._v(" "),s("li",[s("p",[a._v("获取内存dump:jmap -histo:live pid号\n这个方式会先fullgc，如果不希望触发fullgc可以使用jmap -histo pid号")])]),a._v(" "),s("li",[s("p",[a._v("第三种方式：jdk启动加参数\n-XX：+HeapDumpBeforeFullGC\n-XX：HeapDumpPath=/httx/logs/dump\n这种方式会产生dump日志，在通过jvisualvm.exe或者Eclipse Memory Analysis Tools工具进行分析。")])])]),a._v(" "),s("p",[a._v("最后，可以看一下GC日志，观测老年代溢出，还是元空间溢出。\n老年代溢出需要看dump文件中哪些对象没有释放，从而分析代码。\n元空间溢出排查比较麻烦，dump看不出来，一般是因为重复加载class太多，可以分析问题代码，针对性压测，观察class数量")]),a._v(" "),s("h3",{attrs:{id:"json及诶西集中方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#json及诶西集中方式"}},[a._v("#")]),a._v(" json及诶西集中方式")]),a._v(" "),s("ul",[s("li",[a._v("jackson：反射+反射缓存、良好的stream支持、高效的内存管理")]),a._v(" "),s("li",[a._v("fastjson：\n"),s("ul",[s("li",[a._v("jvm虚拟机：通过ASM库运行时生成parser字节码，支持的field不能超过200个。参考：FastJson使用ASM反序列化。")]),a._v(" "),s("li",[a._v("android虚拟机：反射的方式。")])])]),a._v(" "),s("li",[a._v("gson：反射+反射缓存、支持部分stream、内存性能较差（gc问题）。")])]),a._v(" "),s("h4",{attrs:{id:"jackson"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jackson"}},[a._v("#")]),a._v(" Jackson")]),a._v(" "),s("p",[a._v("依赖")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>2.9.6</version>\n</dependency>\n")])])]),s("p",[a._v("使用代码")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('private static ObjectMapper mapper=new ObjectMapper();\nString userJson = "{\\"name\\": \\"jack\\",\\"age\\": \\"20\\"}";\n\n//JSON字符串->Java对象\nUser user = objectMapper.readValue(userJson, User.class);\n//JSON数组字符串->Java对象数组\nUser[] users = objectMapper.readValue(usersJson, User[].class);\n\n//Java对象转JSON字符串\nString jack = objectMapper.writeValueAsString(new User("jack", 20));\n\n//转二进制数组\nbyte[] jacks = objectMapper.writeValueAsBytes(new User("jack", 20));\n')])])]),s("h4",{attrs:{id:"gson"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gson"}},[a._v("#")]),a._v(" Gson")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Gson gson = new Gson();\nPerson person = gson.fromJson(jsonData, Person.class);\n")])])]),s("h4",{attrs:{id:"fastjson"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fastjson"}},[a._v("#")]),a._v(" fastjson")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>fastjson</artifactId>\n                <version>${fastjson.version}</version>\n            </dependency>\n")])])]),s("p",[a._v("JSONObject解析")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('例：\n{\n  "code": 200,\n  "message": "操作成功！",\n  "data": {[\n    "address": "TEfgYPLn3Z8RJ3mTJiwwHtkukZspUWPreF",\n    "list": []\n  ]}\n}\n//java对象转json字符串\nString result = JSON.toJSONString(dingMsg);\n//截取字符串\nString realResult = result.substring(4, result.length());\n//字符串转换JSONObject 对象：\nJSONObject data = JSON.parseObject(realResult);\n//解析对象：\nClass class = JSON.parseObject(realResult , xxx.class);\n//解析对象数组\nJSONObject jsonObject = data.getJSONObject("data");\nList<Class> trxToCNYRate = JSONObject.parseArray(jsonObject.toJSONString(), Class.class);\n\n//获取JSONObject中的对象并解析\nJSONObject jsonObject = data.getJSONObject("data");\nClass class = JSON.parseObject(jsonObject.toJSONString(), xxx.class);\n//解析JSONObject中的string\nString obj = data.getJSONObject("data").getString("address");\n')])])])])}),[],!1,null,null,null);s.default=n.exports}}]);