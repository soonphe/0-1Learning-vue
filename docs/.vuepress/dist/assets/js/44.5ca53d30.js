(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{241:function(t,e,a){t.exports=a.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(t,e,a){t.exports=a.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(t,e,a){t.exports=a.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},343:function(t,e,a){"use strict";a.r(e);var n=a(14),s=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_0-1learning"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[t._v("#")]),t._v(" 0-1Learning")]),t._v(" "),e("p",[e("img",{attrs:{src:a(241),alt:"alt text",title:"公众号"}}),t._v(" "),e("img",{attrs:{src:a(242),alt:"alt text",title:"学习"}}),t._v(" "),e("img",{attrs:{src:a(243),alt:"alt text",title:"微信"}})]),t._v(" "),e("h2",{attrs:{id:"状态管理vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态管理vuex"}},[t._v("#")]),t._v(" 状态管理Vuex")]),t._v(" "),e("p",[t._v("Vuex 是什么？\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension (opens new window)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。")]),t._v(" "),e("h3",{attrs:{id:"什么情况下我应该使用-vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下我应该使用-vuex"}},[t._v("#")]),t._v(" 什么情况下我应该使用 Vuex？")]),t._v(" "),e("p",[t._v("Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式 (opens new window)就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：")]),t._v(" "),e("h3",{attrs:{id:"简单的store模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单的store模式"}},[t._v("#")]),t._v(" 简单的store模式")]),t._v(" "),e("p",[t._v("store 模式：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var store = {\n  debug: true,\n  state: {\n    message: 'Hello!'\n  },\n  setMessageAction (newValue) {\n    if (this.debug) console.log('setMessageAction triggered with', newValue)\n    this.state.message = newValue\n  },\n  clearMessageAction () {\n    if (this.debug) console.log('clearMessageAction triggered')\n    this.state.message = ''\n  }\n}\n")])])]),e("p",[t._v("所有 store 中 state 的变更，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的变更将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。")]),t._v(" "),e("p",[t._v("此外，每个实例/组件仍然可以拥有和管理自己的私有状态：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n")])])]),e("h3",{attrs:{id:"安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[t._v("#")]),t._v(" 安装")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<script src="/path/to/vue.js"><\/script>\n<script src="/path/to/vuex.js"><\/script>\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("npm：\nnpm install vuex --save\n")])])]),e("h3",{attrs:{id:"开始"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开始"}},[t._v("#")]),t._v(" 开始")]),t._v(" "),e("p",[t._v("每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。")])]),t._v(" "),e("li",[e("p",[t._v("你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。")])])]),t._v(" "),e("p",[t._v("安装 Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n")])])]),e("p",[t._v("现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.commit('increment')\n\nconsole.log(store.state.count) // -> 1\n")])])]),e("p",[t._v("为了在 Vue 组件中访问 this.$store property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("new Vue({\n  el: '#app',\n  store: store,\n})\n")])])]),e("p",[t._v("如果使用 ES6，你也可以以 ES6 对象的 property 简写 (用在对象某个 property 的 key 和被传入的变量同名时)：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("new Vue({\n  el: '#app',\n  store\n})\n")])])]),e("p",[t._v("现在我们可以从组件的方法提交一个变更：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("methods: {\n  increment() {\n    this.$store.commit('increment')\n    console.log(this.$store.state.count)\n  }\n}\n")])])]),e("h3",{attrs:{id:"核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[t._v("#")]),t._v(" 核心概念")]),t._v(" "),e("ul",[e("li",[t._v("State：状态")]),t._v(" "),e("li",[t._v("Getters：获取对象")]),t._v(" "),e("li",[t._v("Mutations：变化")]),t._v(" "),e("li",[t._v("Actions：动作")]),t._v(" "),e("li",[t._v("Modules：模块")])]),t._v(" "),e("h4",{attrs:{id:"state"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" state")]),t._v(" "),e("p",[t._v("单一状态树\nVuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT (opens new window))”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。")]),t._v(" "),e("p",[t._v("在 Vue 组件中获得 Vuex 状态")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n")])])]),e("p",[t._v("然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。")]),t._v(" "),e("p",[t._v("Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n")])])]),e("p",[t._v("通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n")])])]),e("p",[t._v("mapState 辅助函数\n当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n")])])]),e("p",[t._v("当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("computed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n")])])]),e("p",[t._v("对象展开运算符\nmapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符 (opens new window)，我们可以极大地简化写法：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("computed: {\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n")])])]),e("p",[t._v("组件仍然保有局部状态\n使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。")]),t._v(" "),e("h4",{attrs:{id:"getter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[t._v("#")]),t._v(" Getter")]),t._v(" "),e("p",[t._v("Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。")]),t._v(" "),e("p",[t._v("Getter 接受 state 作为其第一个参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n")])])]),e("p",[e("strong",[t._v("通过属性访问")]),t._v("\nGetter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n")])])]),e("p",[t._v("Getter 也可以接受其他 getter 作为第二个参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("getters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\n")])])]),e("p",[t._v("注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。")]),t._v(" "),e("p",[t._v("通过方法访问\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("getters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n")])])]),e("p",[e("strong",[t._v("mapGetters 辅助函数")]),t._v("\nmapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import { mapGetters } from 'vuex'\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n")])])]),e("p",[t._v("如果你想将一个 getter 属性另取一个名字，使用对象形式：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("...mapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n")])])]),e("h4",{attrs:{id:"mutations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutations"}},[t._v("#")]),t._v(" Mutations")]),t._v(" "),e("p",[t._v("更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n")])])]),e("p",[t._v("你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.commit('increment')\n")])])]),e("p",[t._v("提交载荷（Payload）\n你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.commit('increment', 10)\n")])])]),e("p",[t._v("在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.commit('increment', {\n  amount: 10\n})\n")])])]),e("p",[t._v("当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("mutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n")])])]),e("p",[t._v("Mutation 需遵守 Vue 的响应规则\n既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：")]),t._v(" "),e("ol",[e("li",[t._v("最好提前在你的 store 中初始化好所有所需属性。")]),t._v(" "),e("li",[t._v("当需要在对象上添加新属性时，你应该")])]),t._v(" "),e("ul",[e("li",[t._v("使用 Vue.set(obj, 'newProp', 123), 或者")]),t._v(" "),e("li",[t._v("以新对象替换老对象。例如，利用对象展开运算符 (opens new window)我们可以这样写：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("state.obj = { ...state.obj, newProp: 123 }\n")])])]),e("p",[t._v("Mutation 必须是同步函数\n一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("mutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n")])])]),e("p",[t._v("现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的")]),t._v(" "),e("h4",{attrs:{id:"actions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#actions"}},[t._v("#")]),t._v(" Actions")]),t._v(" "),e("p",[t._v("Action 类似于 mutation，不同在于：")]),t._v(" "),e("ul",[e("li",[t._v("Action 提交的是 mutation，而不是直接变更状态。")]),t._v(" "),e("li",[t._v("Action 可以包含任意异步操作。")])]),t._v(" "),e("p",[t._v("注册一个简单的 action：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n")])])]),e("p",[t._v("Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。")]),t._v(" "),e("p",[t._v("实践中，我们会经常用到 ES2015 的 参数解构 (opens new window)来简化代码（特别是我们需要调用 commit 很多次的时候）：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("actions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n")])])]),e("p",[t._v("分发 Action\nAction 通过 store.dispatch 方法触发：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.dispatch('increment')\n")])])]),e("p",[t._v("乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("actions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n")])])]),e("p",[t._v("Actions 支持同样的载荷方式和对象方式进行分发：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n")])])]),e("p",[t._v("来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("actions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n")])])]),e("p",[t._v("在组件中分发 Action\n你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n")])])]),e("p",[t._v("组合 Action\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("actions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n")])])]),e("p",[t._v("现在你可以：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("store.dispatch('actionA').then(() => {\n  // ...\n})\n")])])]),e("p",[t._v("在另外一个 action 中也可以：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("actions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n")])])]),e("h4",{attrs:{id:"modules"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modules"}},[t._v("#")]),t._v(" Modules")]),t._v(" "),e("p",[t._v("由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。")]),t._v(" "),e("p",[t._v("为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n")])])]),e("p",[t._v("模块的局部状态\n对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const moduleA = {\n  state: () => ({\n    count: 0\n  }),\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n")])])]),e("p",[t._v("同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n")])])]),e("p",[t._v("对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n")])])]),e("p",[t._v("命名空间\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。")]),t._v(" "),e("p",[t._v("如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n      。。。\n")])])]),e("p",[t._v("模块动态注册\n在 store 创建之后，你可以使用 store.registerModule 方法注册模块：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import Vuex from 'vuex'\n\nconst store = new Vuex.Store({ /* 选项 */ })\n\n// 注册模块 `myModule`\nstore.registerModule('myModule', {\n  // ...\n})\n// 注册嵌套模块 `nested/myModule`\nstore.registerModule(['nested', 'myModule'], {\n  // ...\n})\n")])])]),e("p",[t._v("之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。")]),t._v(" "),e("p",[t._v("模块重用\n有时我们可能需要创建一个模块的多个实例，例如：")]),t._v(" "),e("ul",[e("li",[t._v("创建多个 store，他们公用同一个模块 (例如当 runInNewContext 选项是 false 或 'once' 时，为了在服务端渲染中避免有状态的单例 (opens new window))")]),t._v(" "),e("li",[t._v("在一个 store 中多次注册同一个模块")])]),t._v(" "),e("p",[t._v("如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。\n实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const MyReusableModule = {\n  state: () => ({\n    foo: 'bar'\n  }),\n  // mutation, action 和 getter 等等...\n}\n")])])]),e("h3",{attrs:{id:"项目结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目结构"}},[t._v("#")]),t._v(" 项目结构")]),t._v(" "),e("p",[t._v("项目结构\nVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：")]),t._v(" "),e("ol",[e("li",[t._v("应用层级的状态应该集中到单个 store 对象中。")]),t._v(" "),e("li",[t._v("提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。")]),t._v(" "),e("li",[t._v("异步逻辑都应该封装到 action 里面。")])]),t._v(" "),e("p",[t._v("只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n")])])]),e("h3",{attrs:{id:"插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[t._v("#")]),t._v(" 插件")]),t._v(" "),e("p",[t._v("Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const myPlugin = store => {\n  // 当 store 初始化后调用\n  store.subscribe((mutation, state) => {\n    // 每次 mutation 之后调用\n    // mutation 的格式为 { type, payload }\n  })\n}\n")])])]),e("p",[t._v("使用：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = new Vuex.Store({\n  // ...\n  plugins: [myPlugin]\n})\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);