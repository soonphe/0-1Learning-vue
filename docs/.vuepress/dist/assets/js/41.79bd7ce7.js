(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{241:function(e,t,a){e.exports=a.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(e,t,a){e.exports=a.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(e,t,a){e.exports=a.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},340:function(e,t,a){"use strict";a.r(t);var n=a(14),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_0-1learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[e._v("#")]),e._v(" 0-1Learning")]),e._v(" "),t("p",[t("img",{attrs:{src:a(241),alt:"alt text",title:"公众号"}}),e._v(" "),t("img",{attrs:{src:a(242),alt:"alt text",title:"学习"}}),e._v(" "),t("img",{attrs:{src:a(243),alt:"alt text",title:"微信"}})]),e._v(" "),t("h2",{attrs:{id:"组合和复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合和复用"}},[e._v("#")]),e._v(" 组合和复用")]),e._v(" "),t("h3",{attrs:{id:"混入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#混入"}},[e._v("#")]),e._v(" 混入")]),e._v(" "),t("p",[e._v("基础\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。")]),e._v(" "),t("p",[e._v("例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 定义一个混入对象\nvar myMixin = {\ncreated: function () {\nthis.hello()\n},\nmethods: {\nhello: function () {\nconsole.log('hello from mixin!')\n}\n}\n}\n\n// 定义一个使用混入对象的组件\nvar Component = Vue.extend({\nmixins: [myMixin]\n})\n\nvar component = new Component() // => \"hello from mixin!\"\n")])])]),t("h3",{attrs:{id:"选项合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选项合并"}},[e._v("#")]),e._v(" 选项合并")]),e._v(" "),t("p",[e._v("当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。")]),e._v(" "),t("p",[e._v("比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var mixin = {\n  data: function () {\n    return {\n      message: 'hello',\n      foo: 'abc'\n    }\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: 'goodbye',\n      bar: 'def'\n    }\n  },\n  created: function () {\n    console.log(this.$data)\n    // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" }\n  }\n})\n")])])]),t("p",[e._v("同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。")]),e._v(" "),t("p",[e._v("值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。")]),e._v(" "),t("h3",{attrs:{id:"全局混入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局混入"}},[e._v("#")]),e._v(" 全局混入")]),e._v(" "),t("p",[e._v("混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 为自定义的选项 'myOption' 注入一个处理器。\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// => \"hello!\"\n")])])]),t("blockquote",[t("p",[e._v("请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。")])]),e._v(" "),t("h3",{attrs:{id:"自定义选项合并策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义选项合并策略"}},[e._v("#")]),e._v(" 自定义选项合并策略")]),e._v(" "),t("p",[e._v("自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n// 返回合并后的值\n}\n对于多数值为对象的选项，可以使用与 methods 相同的合并策略：\n\nvar strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods\n可以在 Vuex 1.x 的混入策略里找到一个更高级的例子：\n\nconst merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n  if (!toVal) return fromVal\n  if (!fromVal) return toVal\n  return {\n    getters: merge(toVal.getters, fromVal.getters),\n    state: merge(toVal.state, fromVal.state),\n    actions: merge(toVal.actions, fromVal.actions)\n  }\n}\n")])])]),t("h3",{attrs:{id:"自定义指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[e._v("#")]),e._v(" 自定义指令")]),e._v(" "),t("p",[e._v("除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：")]),e._v(" "),t("p",[e._v("当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n\n如果想注册局部指令，组件中也接受一个 directives 的选项：\n\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n")])])]),t("p",[e._v("然后你可以在模板中任何元素上使用新的 v-focus property，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<input v-focus>\n")])])]),t("h3",{attrs:{id:"钩子函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#钩子函数"}},[e._v("#")]),e._v(" 钩子函数")]),e._v(" "),t("p",[e._v("一个指令定义对象可以提供如下几个钩子函数 (均为可选)：")]),e._v(" "),t("ul",[t("li",[e._v("bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。")]),e._v(" "),t("li",[e._v("inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。")]),e._v(" "),t("li",[e._v("update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。")]),e._v(" "),t("li",[e._v("componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。")]),e._v(" "),t("li",[e._v("unbind：只调用一次，指令与元素解绑时调用。")])]),e._v(" "),t("h3",{attrs:{id:"钩子函数参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#钩子函数参数"}},[e._v("#")]),e._v(" 钩子函数参数")]),e._v(" "),t("p",[e._v("指令钩子函数会被传入以下参数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('el：指令所绑定的元素，可以用来直接操作 DOM。\nbinding：一个对象，包含以下 property：\n    name：指令名，不包括 v- 前缀。\n    value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。\n    oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n    expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。\n    arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。\n    modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\nvnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。\n')])])]),t("h3",{attrs:{id:"函数简写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数简写"}},[e._v("#")]),e._v(" 函数简写")]),e._v(" "),t("p",[e._v("在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.directive('color-swatch', function (el, binding) {\n  el.style.backgroundColor = binding.value\n})\n")])])]),t("h3",{attrs:{id:"对象字面量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象字面量"}},[e._v("#")]),e._v(" 对象字面量")]),e._v(" "),t("p",[e._v("如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\nVue.directive('demo', function (el, binding) {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text)  // => \"hello!\"\n})\n")])])]),t("h3",{attrs:{id:"插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[e._v("#")]),e._v(" 插件")]),e._v(" "),t("p",[e._v("插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：")]),e._v(" "),t("p",[e._v("添加全局方法或者 property。如：vue-custom-element")]),e._v(" "),t("p",[e._v("添加全局资源：指令/过滤器/过渡等。如 vue-touch")]),e._v(" "),t("p",[e._v("通过全局混入来添加一些组件选项。如 vue-router")]),e._v(" "),t("p",[e._v("添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。")]),e._v(" "),t("p",[e._v("一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router")]),e._v(" "),t("p",[e._v("使用插件\n通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue({\n// ...组件选项\n})\n也可以传入一个可选的选项对象：\n\nVue.use(MyPlugin, { someOption: true })\n")])])]),t("p",[e._v("Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。")]),e._v(" "),t("h3",{attrs:{id:"开发插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发插件"}},[e._v("#")]),e._v(" 开发插件")]),e._v(" "),t("p",[e._v("Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或 property\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n")])])]),t("h3",{attrs:{id:"过滤器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过滤器"}},[e._v("#")]),e._v(" 过滤器")]),e._v(" "),t("p",[e._v("Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- 在双花括号中 --\x3e\n{{ message | capitalize }}\n\n\x3c!-- 在 `v-bind` 中 --\x3e\n<div v-bind:id="rawId | formatId"></div>\n')])])]),t("p",[e._v("你可以在一个组件的选项中定义本地的过滤器：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("filters: {\n  capitalize: function (value) {\n    if (!value) return ''\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}\n")])])]),t("p",[e._v("或者在创建 Vue 实例之前全局定义过滤器：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.filter('capitalize', function (value) {\n  if (!value) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n\nnew Vue({\n  // ...\n})\n")])])]),t("p",[e._v("当全局过滤器和局部过滤器重名时，会采用局部过滤器。")]),e._v(" "),t("p",[e._v("过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数。")]),e._v(" "),t("p",[e._v("过滤器可以串联：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{{ message | filterA | filterB }}\n")])])]),t("p",[e._v("在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。")]),e._v(" "),t("p",[e._v("过滤器是 JavaScript 函数，因此可以接收参数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{{ message | filterA('arg1', arg2) }}\n")])])]),t("p",[e._v("这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。")])])}),[],!1,null,null,null);t.default=s.exports}}]);