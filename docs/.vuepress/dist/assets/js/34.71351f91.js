(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{241:function(e,t,n){e.exports=n.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(e,t,n){e.exports=n.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(e,t,n){e.exports=n.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},333:function(e,t,n){"use strict";n.r(t);var a=n(14),i=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_0-1learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[e._v("#")]),e._v(" 0-1Learning")]),e._v(" "),t("p",[t("img",{attrs:{src:n(241),alt:"alt text",title:"公众号"}}),e._v(" "),t("img",{attrs:{src:n(242),alt:"alt text",title:"学习"}}),e._v(" "),t("img",{attrs:{src:n(243),alt:"alt text",title:"微信"}})]),e._v(" "),t("h2",{attrs:{id:"多媒体技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多媒体技术"}},[e._v("#")]),e._v(" 多媒体技术")]),e._v(" "),t("h3",{attrs:{id:"使用通知notification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用通知notification"}},[e._v("#")]),e._v(" 使用通知Notification")]),e._v(" "),t("p",[e._v("通知（Notification）是Android 系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。\n发出一条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。")]),e._v(" "),t("h4",{attrs:{id:"通知的用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通知的用法"}},[e._v("#")]),e._v(" 通知的用法")]),e._v(" "),t("p",[e._v("首先需要一个NotificationManager 来对通知进行管理，可以调用Context 的getSystemService()方法获取到。\ngetSystemService()方法接收一个字符串参数用于确定获取系统的哪个服务， 这里我们传入Context.NOTIFICATION_SERVICE 即可。\n因此， 获取NotificationManager 的实例就可以写成：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);\n\n")])])]),t("p",[e._v("接下来需要创建一个Notification 对象，这个对象用于存储通知所需的各种信息，我们可以使用它的有参构造函数来进行创建。\n第一个参数用于指定通知的图标，比如项目的res/drawable 目录下有一张icon.png 图片，那么这里就可以传入R.drawable.icon。\n第二个参数用于指定通知的ticker 内容，当通知刚被创建的时候，它会在系统的状态栏一闪而过，属于一种瞬时的提示信息。\n第三个参数用于指定通知被创建的时间，以毫秒为单位，当下拉系统状态栏时，这里指定的时间会显示在相应的通知上。\n因此，创建一个Notification 对象就可以写成：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Notification notification = new Notification(R.drawable.icon, "This is ticker text",\nSystem.currentTimeMillis());\n')])])]),t("p",[e._v("创建好了Notification 对象后，我们还需要对通知的布局进行设定，这里只需要调用\nNotification 的setLatestEventInfo()方法就可以给通知设置一个标准的布局。\n第一个参数是Context，这个没什么好解释的。\n第二个参数用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。\n第三个参数用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。\n第四个参数用于指定通知的点击效果，即PendingIntent，可以先传入null，。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('notification.setLatestEventInfo(context, "This is content title", "This is content text", null);\n')])])]),t("p",[e._v("以上工作都完成之后，只需要调用NotificationManager 的notify()方法就可以让通知显示出来了。\nnotify()方法接收两个参数，\n第一个参数是id，要保证为每个通知所指定的id 都是不同的。\n第二个参数则是Notification 对象，这里直接将我们刚刚创建好的Notification 对象传入即可。\n因此，显示一个通知就可以写成：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("manager.notify(1, notification);\n")])])]),t("h4",{attrs:{id:"通知的点击效果pendingintent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通知的点击效果pendingintent"}},[e._v("#")]),e._v(" 通知的点击效果PendingIntent")]),e._v(" "),t("p",[e._v("PendingIntent 从名字上看起来就和Intent 有些类似，它们之间也确实存在着不少共同点。\n比如它们都可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等。\n不同的是，Intent 更加倾向于去立即执行某个动作，而PendingIntent 更加倾向于在某个合适的时机去执行某个动作。\n所以，也可以把PendingIntent 简单地理解为延迟执行的Intent。\nPendingIntent 的用法同样很简单，它主要提供了几个静态方法用于获取PendingIntent 的实例，\ngetActivity()方法：启动一个活动\ngetBroadcast()方法：发送广播\n还是getService()方法：启动服务")]),e._v(" "),t("p",[e._v("这几个方法所接收的参数都是相同的，\n第一个参数依旧是Context，不用多做解释。\n第二个参数一般用不到，通常都是传入0 即可。\n第三个参数是一个Intent 对象，我们可以通过这个对象构建出PendingIntent 的“意图”。\n第四个参数用于确定PendingIntent 的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT 和FLAG_UPDATE_CURRENT 这四种值可选，")]),e._v(" "),t("p",[e._v("因此，Notification 的setLatestEventInfo()方法的第四个参数传入PendingIntent 构建出一个延迟执行的“意图”，当用户点击这条通知时就会执行相应的逻辑。")]),e._v(" "),t("p",[e._v("代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);\nNotification notification = new Notification(R.drawable.ic_launcher, "This is ticker text", System.currentTimeMillis());\nIntent intent = new Intent(this, NotificationActivity.class);\nPendingIntent pi = PendingIntent.getActivity(this, 0, intent,PendingIntent.FLAG_CANCEL_CURRENT);\nnotification.setLatestEventInfo(this, "This is content title","This is content text", pi);\nmanager.notify(1, notification);\n')])])]),t("p",[e._v("通知取消\n调用NotificationManager 的cancel()方法就可以取消通知了。\n当时我们给这条通知设置的id 就是1。因此，如果你想要取消哪一条通知，就在cancel()方法中传入该通知的id 就行了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);\nmanager.cancel(1);\n")])])]),t("h4",{attrs:{id:"通知的高级技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通知的高级技巧"}},[e._v("#")]),e._v(" 通知的高级技巧")]),e._v(" "),t("ol",[t("li",[e._v("播放音频")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Uri soundUri = Uri.fromFile(new File("/system/media/audio/ringtones/\nBasic_tone.ogg"));\nnotification.sound = soundUri;\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("设置震动")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('例：所以，如果想要让手机在通知到来的时候立刻振动1 秒，然后静止1 秒，再振动1 秒，代码就可以写成：\nlong[] vibrates = {0, 1000, 1000, 1000};\nnotification.vibrate = vibrates;\n\n不过，想要控制手机振动还需要声明权限的。因此，我们还得编辑AndroidManifest.xml\n文件，加入如下声明：\n<uses-permission android:name="android.permission.VIBRATE" />\n……\n')])])]),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[e._v("设置前置LED灯\nledARGB 用于控制LED 灯的颜色，一般有红绿蓝三种颜色可选。\nledOnMS 用于指定LED 灯亮起的时长，以毫秒为单位。\nledOffMS用于指定LED 灯暗去的时长，也是以毫秒为单位。\nflags 可用于指定通知的一些行为，其中就包括显示LED 灯这一选项。\n所以，当通知到来时，如果想要实现LED 灯以绿色的灯光一闪一闪的效果，就可以写成：\nnotification.ledARGB = Color.GREEN;\nnotification.ledOnMS = 1000;\nnotification.ledOffMS = 1000;\nnotification.flags = Notification.FLAG_SHOW_LIGHTS;")])]),e._v(" "),t("li",[t("p",[e._v("使用通知的默认效果\n当然，如果你不想进行那么多繁杂的设置，也可以直接使用通知的默认效果，它会根据\n当前手机的环境来决定播放什么铃声，以及如何振动，写法如下：\nnotification.defaults = Notification.DEFAULT_ALL;\n注意，以上所涉及的这些高级技巧都要在手机上运行才能看得到效果，模拟器是无法表现出振动、以及LED 灯闪烁等功能的。")])])]),e._v(" "),t("h3",{attrs:{id:"接收和发送短信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接收和发送短信"}},[e._v("#")]),e._v(" 接收和发送短信")]),e._v(" "),t("h4",{attrs:{id:"接受短信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接受短信"}},[e._v("#")]),e._v(" 接受短信")]),e._v(" "),t("p",[e._v("其实接收短信主要是利用了我们在第5 章学习过的广播机制。\n当手机接收到一条短信的时候，系统会发出一条值为android.provider.Telephony.SMS_RECEIVED 的广播，\n这条广播里携带着与短信相关的所有数据。每个应用程序都可以在广播接收器里对它进行监听，收到广播时再从中解析出短信的内容即可。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('1.创建一个广播接收器来接收系统发出的短信广播\nclass MessageReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Bundle bundle = intent.getExtras();\n        Object[] pdus = (Object[]) bundle.get("pdus"); // 提取短信消息\n        SmsMessage[] messages = new SmsMessage[pdus.length];\n        for (int i = 0; i < messages.length; i++) {\n        messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i]);\n    }\n    String address = messages[0].getOriginatingAddress(); // 获取发送方号码\n    String fullMessage = "";\n    for (SmsMessage message : messages) {\n        fullMessage += message.getMessageBody(); // 获取短信内容\n    }\n    sender.setText(address);\n    content.setText(fullMessage);\n}\n\n2.MessageReceiver 进行注册才能让它接收到短信广播，代码如下所示：\npublic class MainActivity extends Activity {\n    private TextView sender;\n    private TextView content;\n    private IntentFilter receiveFilter;\n    private MessageReceiver messageReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        sender = (TextView) findViewById(R.id.sender);\n        content = (TextView) findViewById(R.id.content);\n        receiveFilter = new IntentFilter();\n        receiveFilter.addAction("android.provider.Telephony.SMS_RECEIVED");\n        messageReceiver = new MessageReceiver();\n        registerReceiver(messageReceiver, receiveFilter);\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(messageReceiver);\n    }\n……\n}\n\n')])])]),t("h4",{attrs:{id:"拦截短信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拦截短信"}},[e._v("#")]),e._v(" 拦截短信")]),e._v(" "),t("p",[e._v("我们就已经知道，有序广播的传递是可以截断的，而系统发出的短信广播正是一条有序广播，因此")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class MainActivity extends Activity {\n    ……\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        ……\n        receiveFilter = new IntentFilter();\n        receiveFilter.addAction("android.provider.Telephony.SMS_RECEIVED");\n        receiveFilter.setPriority(100);\n        messageReceiver = new MessageReceiver();\n        registerReceiver(messageReceiver, receiveFilter);\n    }\n    ……\n    class MessageReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            ……\n            abortBroadcast();\n        }\n    }\n}\n')])])]),t("h4",{attrs:{id:"发送短信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送短信"}},[e._v("#")]),e._v(" 发送短信")]),e._v(" "),t("p",[e._v("sendTextMessage()方法接收五个参数，\n其中第一个参数用于指定接收人的手机号码，\n第三个参数用于指定短信的内容，\n第四个参数用于监控短信发送状态回执，例：PendingIntent pi = PendingIntent.getBroadcast(MainActivity.this, 0, sentIntent, 0);\n其他的几个参数我们暂时用不到，直接传入null就可以了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('SmsManager smsManager = SmsManager.getDefault();\nsmsManager.sendTextMessage(to.getText().toString(), null,msgInput.getText().toString(), null, null);\n\n权限申请：\n<uses-permission android:name="android.permission.RECEIVE_SMS" />\n<uses-permission android:name="android.permission. SEND_SMS" />\n……\n\n')])])]),t("h3",{attrs:{id:"调用摄像头和相册"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用摄像头和相册"}},[e._v("#")]),e._v(" 调用摄像头和相册")]),e._v(" "),t("h4",{attrs:{id:"调用摄像头拍照"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用摄像头拍照"}},[e._v("#")]),e._v(" 调用摄像头拍照")]),e._v(" "),t("p",[e._v("主要分为两步:1.启动相机程序  2.获取保存的图片")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('1.启动相机程序\nprivate Uri imageUri;\n// 创建File对象，用于存储拍照后的图片\nFile outputImage = new File(Environment.getExternalStorageDirectory(), "tempImage.jpg");\nimageUri = Uri.fromFile(outputImage);\n\nIntent intent = new Intent("android.media.action. IMAGE_CAPTURE");\nintent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);\nstartActivityForResult(intent, TAKE_PHOTO); // 启动相机程序\n\n2.获取保存的图片（这里使用onActivityResult实现）\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    switch (requestCode) {\n        case TAKE_PHOTO:\n            if (resultCode == RESULT_OK) {\n                Intent intent = new Intent("com.android.camera.action.CROP");\n                intent.setDataAndType(imageUri, "image/*");\n                intent.putExtra("scale", true);\n                intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);\n                startActivityForResult(intent, CROP_PHOTO); // 启动裁剪程序\n            }\n        break;\n        case CROP_PHOTO:\n            if (resultCode == RESULT_OK) {\n                try {\n                    Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));\n                    picture.setImageBitmap(bitmap); // 将裁剪后的照片显示出来\n                } catch (FileNotFoundException e) {\n                    e.printStackTrace();\n                }\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n权限：<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />\n')])])]),t("h4",{attrs:{id:"从相册中选择照片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从相册中选择照片"}},[e._v("#")]),e._v(" 从相册中选择照片")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 创建File对象，用于存储选择的照片\nFile outputImage = new File(Environment.\ngetExternalStorageDirectory(), "output_image.jpg");\ntry {\n    if (outputImage.exists()) {\n        outputImage.delete();\n    }\n    outputImage.createNewFile();\n} catch (IOException e) {\n    e.printStackTrace();\n}\nimageUri = Uri.fromFile(outputImage);\nIntent intent = new Intent("android.intent.action.GET_CONTENT");\nintent.setType("image/*");\nintent.putExtra("crop", true);\nintent.putExtra("scale", true);\nintent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);\nstartActivityForResult(intent, CROP_PHOTO);\n')])])]),t("h3",{attrs:{id:"播放多媒体文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#播放多媒体文件"}},[e._v("#")]),e._v(" 播放多媒体文件")]),e._v(" "),t("h4",{attrs:{id:"播放音频"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#播放音频"}},[e._v("#")]),e._v(" 播放音频")]),e._v(" "),t("p",[e._v("在Android 中播放音频文件一般都是使用MediaPlayer 类来实现的，下表列出了MediaPlayer 类中一些较为常用的控制方法。")]),e._v(" "),t("p",[e._v("setDataSource() 设置要播放的音频文件的位置。\nprepare() 在开始播放之前调用这个方法完成准备工作。\nstart() 开始或继续播放音频。\npause() 暂停播放音频。\nreset() 将MediaPlayer 对象重置到刚刚创建的状态。\nseekTo() 从指定的位置开始播放音频。\nstop() 停止播放音频。调用这个方法后的MediaPlayer 对象无法再播放音频。\nrelease() 释放掉与MediaPlayer 对象相关的资源。\nisPlaying() 判断当前MediaPlayer 是否正在播放音频。\ngetDuration() 获取载入的音频文件的时长")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('1.初始化MediaPlayer()\nprivate void initMediaPlayer() {\n    try {\n        File file = new File(Environment.getExternalStorageDirectory(),"music.mp3");\n        mediaPlayer.setDataSource(file.getPath()); // 指定音频文件的路径\n        mediaPlayer.prepare(); // 让MediaPlayer进入到准备状态\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n2.开始播放\nmediaPlayer.start(); // 开始播放\n3.暂停\nmediaPlayer.pause(); // 暂停播放\n4.停止播放\nmediaPlayer.reset(); // 停止播放\ninitMediaPlayer();  //停止后如需重新播放需要重新初始化\n\n5.释放MediaPlayer\nprotected void onDestroy() {\n    super.onDestroy();\n    if (mediaPlayer != null) {\n        mediaPlayer.stop();\n        mediaPlayer.release();\n    }\n}\n')])])]),t("h4",{attrs:{id:"播放视频"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#播放视频"}},[e._v("#")]),e._v(" 播放视频")]),e._v(" "),t("p",[e._v("播放视频文件其实并不比播放音频文件复杂，主要是使用VideoView 类来实现的。主要有以下常用方法：")]),e._v(" "),t("p",[e._v("setVideoPath() 设置要播放的视频文件的位置。\nstart() 开始或继续播放视频。\npause() 暂停播放视频。\nresume() 将视频重头开始播放。\nseekTo() 从指定的位置开始播放视频。\nisPlaying() 判断当前是否正在播放视频。\ngetDuration() 获取载入的视频文件的时长。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('1.初始化VideoView\nprivate void initVideoPath() {\nFile file = new File(Environment.getExternalStorageDirectory(),\n"movie.3gp");\nvideoView.setVideoPath(file.getPath()); // 指定视频文件的路径\n}\n\nvideoView.start(); // 开始播放\nvideoView.pause(); // 暂时播放\nvideoView.resume(); // 重新播放\n\n2.释放VideoView\n@Override\nprotected void onDestroy() {\nsuper.onDestroy();\nif (videoView != null) {\nvideoView.suspend();\n}\n}\n')])])])])}),[],!1,null,null,null);t.default=i.exports}}]);