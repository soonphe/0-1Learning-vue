(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{241:function(t,a,e){t.exports=e.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(t,a,e){t.exports=e.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(t,a,e){t.exports=e.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},330:function(t,a,e){"use strict";e.r(a);var n=e(14),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_0-1learning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[t._v("#")]),t._v(" 0-1Learning")]),t._v(" "),a("p",[a("img",{attrs:{src:e(241),alt:"alt text",title:"公众号"}}),t._v(" "),a("img",{attrs:{src:e(242),alt:"alt text",title:"学习"}}),t._v(" "),a("img",{attrs:{src:e(243),alt:"alt text",title:"微信"}})]),t._v(" "),a("h2",{attrs:{id:"碎片fragment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片fragment"}},[t._v("#")]),t._v(" 碎片Fragment")]),t._v(" "),a("h3",{attrs:{id:"碎片是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片是什么"}},[t._v("#")]),t._v(" 碎片是什么")]),t._v(" "),a("p",[t._v("碎片（Fragment）是一种可以嵌入在活动当中的UI 片段，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用的非常广泛。\n碎片和活动一样，都能包含布局，同样都有自己的生命周期。")]),t._v(" "),a("h3",{attrs:{id:"碎片的使用方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片的使用方式"}},[t._v("#")]),t._v(" 碎片的使用方式")]),t._v(" "),a("h4",{attrs:{id:"碎片的简单用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片的简单用法"}},[t._v("#")]),t._v(" 碎片的简单用法")]),t._v(" "),a("p",[t._v("1.编写碎片布局R.layout.left_fragment\n2.实现Fragment代码\n例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public class LeftFragment extends Fragment {\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n        Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.left_fragment, container, false);\n        return view;\n    }\n}\n")])])]),a("p",[t._v("3.引用fragment")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<fragment\n    android:id="@+id/left_fragment"\n    android:name="com.example.fragmenttest.LeftFragment"\n    android:layout_width="0dp"\n    android:layout_height="match_parent"\n    android:layout_weight="1" />\n')])])]),a("h4",{attrs:{id:"动态添加碎片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态添加碎片"}},[t._v("#")]),t._v(" 动态添加碎片")]),t._v(" "),a("p",[t._v("1.编写碎片布局R.layout.left_fragment\n2.实现Fragment代码\n3.在主Activity动态操作fragment")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("AnotherRightFragment fragment = new AnotherRightFragment();\nFragmentManager fragmentManager = getFragmentManager(); //fragment管理器\nFragmentTransaction transaction = fragmentManager.beginTransaction();   //开启事务\ntransaction.replace(R.id.right_layout, fragment);   //替换布局为fragment\ntransaction.commit();       //提交事务\n")])])]),a("h4",{attrs:{id:"碎片添加返回栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片添加返回栈"}},[t._v("#")]),t._v(" 碎片添加返回栈")]),t._v(" "),a("p",[t._v("transaction.addToBackStack(null);")]),t._v(" "),a("h3",{attrs:{id:"碎片和活动之间进行通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片和活动之间进行通信"}},[t._v("#")]),t._v(" 碎片和活动之间进行通信")]),t._v(" "),a("p",[t._v("活动调用碎片：\nRightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment);")]),t._v(" "),a("p",[t._v("碎片调用活动：\nMainActivity activity = (MainActivity) getActivity();\n获取Context 对象时，也可以使用getActivity()方法，因为获取到的活动本身就是一个Context对象")]),t._v(" "),a("p",[t._v("碎片调用碎片：\n先获取关联的活动，再获取另一个碎片")]),t._v(" "),a("h3",{attrs:{id:"碎片的状态和回调"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#碎片的状态和回调"}},[t._v("#")]),t._v(" 碎片的状态和回调")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("运行状态\n当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。")])]),t._v(" "),a("li",[a("p",[t._v("暂停状态\n当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关联的可见碎片就会进入到暂停状态。")])]),t._v(" "),a("li",[a("p",[t._v("停止状态\n当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态。或者通过调\n用FragmentTransaction 的remove()、replace()方法将碎片从活动中移除，但有在事务提\n交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入\n停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。")])]),t._v(" "),a("li",[a("p",[t._v("销毁状态\n碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。\n或者通过调用FragmentTransaction 的remove()、replace()方法将碎片从活\n动中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入到销毁状态")])])]),t._v(" "),a("p",[t._v("回调方法：")]),t._v(" "),a("ol",[a("li",[t._v("onAttach()\n当碎片和活动建立关联的时候调用。")]),t._v(" "),a("li",[t._v("onCreateView()\n为碎片创建视图（加载布局）时调用。")]),t._v(" "),a("li",[t._v("onActivityCreated()\n确保与碎片相关联的活动一定已经创建完毕的时候调用。")]),t._v(" "),a("li",[t._v("onDestroyView()\n当与碎片关联的视图被移除的时候调用。")]),t._v(" "),a("li",[t._v("onDetach()\n当碎片和活动解除关联的时候调用。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);