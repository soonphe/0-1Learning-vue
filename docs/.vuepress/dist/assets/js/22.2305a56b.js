(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{241:function(t,a,e){t.exports=e.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(t,a,e){t.exports=e.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(t,a,e){t.exports=e.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},309:function(t,a,e){t.exports=e.p+"assets/img/java_exception.f802abd5.png"},363:function(t,a,e){"use strict";e.r(a);var i=e(14),r=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_0-1learning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[t._v("#")]),t._v(" 0-1Learning")]),t._v(" "),a("p",[a("img",{attrs:{src:e(241),alt:"alt text",title:"公众号"}}),t._v(" "),a("img",{attrs:{src:e(242),alt:"alt text",title:"学习"}}),t._v(" "),a("img",{attrs:{src:e(243),alt:"alt text",title:"微信"}})]),t._v(" "),a("h2",{attrs:{id:"异常处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异常处理"}},[t._v("#")]),t._v(" 异常处理")]),t._v(" "),a("h3",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("ul",[a("li",[t._v("异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(100/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。")])]),t._v(" "),a("h3",{attrs:{id:"要点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要点"}},[t._v("#")]),t._v(" 要点")]),t._v(" "),a("ul",[a("li",[t._v("异常类的继承关系")]),t._v(" "),a("li",[t._v("抓抛模型")]),t._v(" "),a("li",[t._v("try-catch-finally关键字")]),t._v(" "),a("li",[t._v("throw和throws关键字")])]),t._v(" "),a("h3",{attrs:{id:"异常是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异常是什么"}},[t._v("#")]),t._v(" 异常是什么")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("异常 是在程序执行过程中发生的一些不希望发生的事情，这些事情如果不被好好处理，就会导致奇怪的结果或者是程序终结。Exception Hander是那些当异常发生时处理这些异常的代码。java和javascript都用try／catch来处理异常。​")])]),t._v(" "),a("li",[a("p",[t._v("程序运行过程时都可能发生会打断程序正常执行的事件。比如除数为零0、数组下标越界、文件找不到、内存不足等。")])]),t._v(" "),a("li",[a("p",[t._v("Java异常处理")]),t._v(" "),a("ul",[a("li",[t._v("利用抓抛模型处理异常")]),t._v(" "),a("li",[t._v("利用面向对象的方法来处理异常")])])])]),t._v(" "),a("h3",{attrs:{id:"异常类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异常类型"}},[t._v("#")]),t._v(" 异常类型")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("产生一个异常就是由系统（JVM）自动的实例化一个异常类的 对象。")]),t._v(" "),a("ul",[a("li",[t._v("称为抛出异常")])])]),t._v(" "),a("li",[a("p",[t._v("异常的继承树")]),t._v(" "),a("ul",[a("li",[t._v("检查性异常（checked exception）")]),t._v(" "),a("li",[t._v("非检查性异常（unchecked exception）\n"),a("img",{attrs:{src:e(309),alt:"alt text"}})])])])]),t._v(" "),a("h3",{attrs:{id:"java异常架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java异常架构"}},[t._v("#")]),t._v(" Java异常架构")]),t._v(" "),a("h4",{attrs:{id:"throwable-结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#throwable-结构"}},[t._v("#")]),t._v(" Throwable 结构")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('* Throwable是 Java 语言中所有错误或异常的超类。 \n* Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。\n* Throwable包含两个子类:\n    * Error\n        * 和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 \n        * 和RuntimeException一样， 编译器也不会检查Error。\n    * Exception\n        * Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。\n        * RuntimeException\n            * RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 \n            * 编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既"没有通过throws声明抛出ArithmeticException异常"，也"没有通过try...catch...处理该异常"，也能通过编译。这就是我们所说的"编译器不会检查RuntimeException异常"！ \n            * 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！\n')])])]),a("h4",{attrs:{id:"throwable三种类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#throwable三种类型"}},[t._v("#")]),t._v(" Throwable三种类型：")]),t._v(" "),a("ul",[a("li",[t._v("被检查的异常(Checked Exception)")]),t._v(" "),a("li",[t._v("运行时异常(RuntimeException)")]),t._v(" "),a("li",[t._v("错误(Error)。")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("运行时异常")]),t._v(" "),a("ul",[a("li",[t._v("定义 : RuntimeException及其子类都被称为运行时异常。")]),t._v(" "),a("li",[t._v('特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既"没有通过throws声明抛出它"，也"没有用try-catch语句捕获它"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。')]),t._v(" "),a("li",[t._v("虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。")]),t._v(" "),a("li",[t._v("如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！")])])]),t._v(" "),a("li",[a("p",[t._v("被检查的异常")]),t._v(" "),a("ul",[a("li",[t._v('定义 :  Exception类本身，以及Exception的子类中除了"运行时异常"之外的其它子类都属于被检查异常。')]),t._v(" "),a("li",[t._v("特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。")]),t._v(" "),a("li",[t._v("例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。")]),t._v(" "),a("li",[t._v("被检查异常通常都是可以恢复的。")])])]),t._v(" "),a("li",[a("p",[t._v("错误")]),t._v(" "),a("ul",[a("li",[t._v("定义 : Error类及其子类。")]),t._v(" "),a("li",[t._v("特点 : 和运行时异常一样，编译器也不会对错误进行检查。")]),t._v(" "),a("li",[t._v("当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。")]),t._v(" "),a("li",[t._v("按照Java惯例，我们是不应该是实现任何新的Error子类的！")])])])]),t._v(" "),a("ul",[a("li",[t._v("说明： 对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。")])]),t._v(" "),a("h3",{attrs:{id:"常见异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见异常"}},[t._v("#")]),t._v(" 常见异常")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("运行时异常：")]),t._v(" "),a("ul",[a("li",[t._v("ArithmeticException:算术溢出异常")]),t._v(" "),a("li",[t._v("ClassCastException:类型转换异常")]),t._v(" "),a("li",[t._v("IllegalClassFormatException：方法参数的数据类型不正确")]),t._v(" "),a("li",[t._v("NullPointerException:空指针异常")]),t._v(" "),a("li",[t._v("ArrayIndexOutOfBoundsException:数组越界")])])]),t._v(" "),a("li",[a("p",[t._v("检查异常：")]),t._v(" "),a("ul",[a("li",[t._v("ClassNotFoundException：找不到类异常")]),t._v(" "),a("li",[t._v("InterruptedException:中断异常")]),t._v(" "),a("li",[t._v("IOException：输入输出流异常")]),t._v(" "),a("li",[t._v("FileNotFoundException:找不到文件异常")])])])]),t._v(" "),a("h3",{attrs:{id:"方法调用堆栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法调用堆栈"}},[t._v("#")]),t._v(" 方法调用堆栈")]),t._v(" "),a("ul",[a("li",[t._v("后进先出")])]),t._v(" "),a("h3",{attrs:{id:"抛出异常对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抛出异常对象"}},[t._v("#")]),t._v(" 抛出异常对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Exception in thread "main" \n    java.lang.ArrayIndexOutOfBoundsException: 5 \n    at Sample.methodThree(Sample.java:17)\n    at Sample.methodTwo(Sample.java:13) \n    at Sample.methodOne(Sample.java:9) \n    at Sample.main(Sample.java:5)\nPress any key to continue...\n')])])]),a("h3",{attrs:{id:"捕获异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕获异常"}},[t._v("#")]),t._v(" 捕获异常")]),t._v(" "),a("ul",[a("li",[t._v("try块和catch块try块和catch块")]),t._v(" "),a("li",[t._v("catch块，是用来捕获并处理try块抛出的异常的代码块。没有try块，catch块不能单独存在。我们可以有多个catch块，以捕获不同类型的异常。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('try{\n\tSystem.out.println(arr[3]);\n\tSystem.out.println("Three"); 19\t\n} catch(ArrayIndexOutOfBoundsException ex){\n    System.out.println("catched"); \n}\n\n')])])]),a("h3",{attrs:{id:"抓抛模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抓抛模型"}},[t._v("#")]),t._v(" 抓抛模型")]),t._v(" "),a("ul",[a("li",[t._v("如果程序抛出多个不同类型的异常，我们需要多个catch()语句来处理。")]),t._v(" "),a("li",[t._v("和特殊异常类相关联的catch()块必须写在和普 通异常类相关联的catch() 之前。")])]),t._v(" "),a("h3",{attrs:{id:"finally块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#finally块"}},[t._v("#")]),t._v(" finally块")]),t._v(" "),a("ul",[a("li",[t._v("在try-catch之后存在finally 块，表示执行try-catch块以后，无论有无抛出Exception，最后必须执行finally块的代码。")]),t._v(" "),a("li",[t._v("通常在finally块中编写将资源返还给系统的语句，它一般包括：")]),t._v(" "),a("li",[t._v("释放动态分配的内存块")]),t._v(" "),a("li",[t._v("关闭文件")]),t._v(" "),a("li",[t._v("关闭数据库结果集")]),t._v(" "),a("li",[t._v("关闭与数据库建立的连接")])]),t._v(" "),a("h3",{attrs:{id:"throw语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#throw语句"}},[t._v("#")]),t._v(" throw语句")]),t._v(" "),a("ul",[a("li",[t._v("二次抛出")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('catch(Exception e) {\nSystem.out.println("一个异常已经产生"); throw e;\n}\n\nthrow new IOException();\n')])])]),a("h4",{attrs:{id:"throws声明方法抛出异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#throws声明方法抛出异常"}},[t._v("#")]),t._v(" throws声明方法抛出异常")]),t._v(" "),a("ul",[a("li",[t._v("throws用来声明一个成员函数可能抛出的各种“异常”")]),t._v(" "),a("li",[t._v("位置：函数头的后面")]),t._v(" "),a("li",[t._v("方法中如果抛出：\n"),a("ul",[a("li",[t._v("非检查性异常：去除Bug，直到不抛出异常；")]),t._v(" "),a("li",[t._v("检查性异常")])])]),t._v(" "),a("li",[t._v("不进行处理，编译通不过。")]),t._v(" "),a("li",[t._v("在该函数内try-catch，把异常处理掉。那么不往上一级抛出异常，程序正常执行，上一级方法并不知道曾经产生异常。")]),t._v(" "),a("li",[t._v("用throws声明方法抛出异常，不进行处理。谁调用谁 负责处理。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('01\tclass ThrowsDemo{\n02\tpublic static void proc( ) throws IOException{ \n03\t\tSystem.out.println("inside proc");\n04\t\tthrow new IOException("ThrowsDemo"); \n05\t}\n06\tpublic static void main(String args[ ]){ \n07\t\ttry{\n08\t        proc ();\n09\t    }catch(IOException e){\n10\t\t    System.out.println("caught"+e); \n11\t    }\n12\t}\n13 }\n')])])]),a("h3",{attrs:{id:"用户自定义异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户自定义异常"}},[t._v("#")]),t._v(" 用户自定义异常")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("如果Java提供的异常类型不能满足程序设计的需要，我们可以\n定义自己的异常类型。")])]),t._v(" "),a("li",[a("p",[t._v("继承Exception类或其子类")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);