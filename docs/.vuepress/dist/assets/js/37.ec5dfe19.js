(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{241:function(t,i,e){t.exports=e.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(t,i,e){t.exports=e.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(t,i,e){t.exports=e.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},335:function(t,i,e){"use strict";e.r(i);var a=e(14),n=Object(a.a)({},(function(){var t=this,i=t._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"_0-1learning"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[t._v("#")]),t._v(" 0-1Learning")]),t._v(" "),i("p",[i("img",{attrs:{src:e(241),alt:"alt text",title:"公众号"}}),t._v(" "),i("img",{attrs:{src:e(242),alt:"alt text",title:"学习"}}),t._v(" "),i("img",{attrs:{src:e(243),alt:"alt text",title:"微信"}})]),t._v(" "),i("h2",{attrs:{id:"android-overview"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#android-overview"}},[t._v("#")]),t._v(" android-overview")]),t._v(" "),i("h3",{attrs:{id:"gradle"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gradle"}},[t._v("#")]),t._v(" Gradle")]),t._v(" "),i("p",[t._v("Gradle wrapper：用来管理版本与相关控制\n其中gradle-wrapper.jar ，是使用gradle-wrapper的一个辅助库\ngradle-wrapper.properties：是gradle-wrapper的配置文件，里面配置了gradle的版本\ngradle配置必须与Gradle plugin版本匹配，否则编译就会失败")]),t._v(" "),i("p",[i("strong",[t._v("Gradle plugin：位于项目的根目录下的build.gradle中配置的插件")])]),t._v(" "),i("blockquote",[i("p",[t._v("gradle配置必须与Gradle wrapper版本不匹配，编译就会失败。")])]),t._v(" "),i("p",[t._v("gradlew：W意思是wrapper，它是一个用bash命令包装过的gradle编译启动脚本，里面会进行环境变量检测和设置。最终进行编译的还是gradle")]),t._v(" "),i("p",[t._v('首次导入项目的时候AS默认是使用 gradle-wrapper-properties 中默认的设置，它会从网上下载所需要的对应版本的 gradle\n解决方法一(断网操作)：AS设置,快捷键 ctrl+alt+s,在搜索框输入gradle，选择gradle本地编译\n解决方法二：删除gradle-wrapper-properties 中的最后一行网址（distributionUrl=""）')]),t._v(" "),i("p",[t._v("gradlehome：C:\\Users\\anna.gradle\\wrapper\\dists\n可以设置gradlehome的环境变量，变量值为：gradlehome路径 + gradle-2.14.1-all\\8bnwg5hd3w55iofp58khbp6yv（项目对应的gradle版本）\n设置环境变量可以解决导入不了项目的问题,但是每次导入都得重新设置一遍")]),t._v(" "),i("h3",{attrs:{id:"andorid-分辨率"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#andorid-分辨率"}},[t._v("#")]),t._v(" Andorid 分辨率")]),t._v(" "),i("p",[t._v("dpi范围\t密度\n0dpi ~ 120dpi\tldpi\n120dpi ~ 160dpi\tmdpi\t1\n160dpi ~ 240dpi\thdpi\t1.5\n240dpi ~ 320dpi\txhdpi\t2\n320dpi ~ 480dpi\txxhdpi\t3\n480dpi ~ 640dpi\txxxhdpi\t4")]),t._v(" "),i("p",[t._v("ico尺寸\n密度\t建议尺寸\nmipmap-mdpi\t48 * 48\nmipmap-hdpi\t72 * 72\nmipmap-xhdpi\t96 * 96\nmipmap-xxhdpi\t144 * 144\nmipmap-xxxhdpi\t192 * 192")]),t._v(" "),i("p",[t._v("不同分辨率图片放大缩小规则：\n图片所有文件dpi x 图片尺寸 = 手机dpi\n图片所有文件dpi越小，图片尺寸越大\n图片所有文件dpi越大，图片尺寸越小\n放大倍数未dpi之间的倍数")]),t._v(" "),i("p",[t._v("占用内存的算法是 (图片所属资源密度 / 手机DPI * 原始图片宽度) * (图片所属资源密度 / 手机DPI * 原始图片高度)")]),t._v(" "),i("p",[t._v("adb查看手机分辨率：\nadb shell dumpsys window displays\n结果：init=1080x1920 420dpi cur=1080x1920 app=1080x1920 rng=1080x1017-1920x1857")]),t._v(" "),i("h3",{attrs:{id:"android图片中的三级缓存"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#android图片中的三级缓存"}},[t._v("#")]),t._v(" Android图片中的三级缓存")]),t._v(" "),i("p",[t._v("为什么要使用三级缓存")]),t._v(" "),i("ul",[i("li",[t._v("如今的 Android App 经常会需要网络交互，通过网络获取图片是再正常不过的事了")]),t._v(" "),i("li",[t._v("假如每次启动的时候都从网络拉取图片的话，势必会消耗很多流量。在当前的状况下，对于非wifi用户来说，流量还是很贵的，一个很耗流量的应用，其用户数量级肯定要受到影响")]),t._v(" "),i("li",[t._v("特别是，当我们想要重复浏览一些图片时，如果每一次浏览都需要通过网络获取，流量的浪费可想而知")]),t._v(" "),i("li",[t._v("所以提出三级缓存策略，通过网络、本地、内存三级缓存图片，来减少不必要的网络交互，避免浪费流量")])]),t._v(" "),i("p",[t._v("什么是三级缓存")]),t._v(" "),i("ul",[i("li",[t._v("网络加载，不优先加载，速度慢，浪费流量")]),t._v(" "),i("li",[t._v("本地缓存，次优先加载，速度快")]),t._v(" "),i("li",[t._v("内存缓存，优先加载，速度最快")])]),t._v(" "),i("p",[t._v("三级缓存原理")]),t._v(" "),i("ul",[i("li",[t._v("之后运行 App 时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中的图片")]),t._v(" "),i("li",[t._v("总之，只在初次访问新内容时，才通过网络获取图片资源")])]),t._v(" "),i("h3",{attrs:{id:"android自定义dialog"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#android自定义dialog"}},[t._v("#")]),t._v(" Android自定义Dialog")]),t._v(" "),i("p",[t._v("调用方式一：获取dialog 的Window，然后调用setContentView方法\n1.编写自定义Dialog View\n2.程序中调用")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("String info = cityData.getPointerList().get(position).toString();  \nAlertDialog alertDialog = new AlertDialog.Builder(CityActivity.this).create();  \nalertDialog.show();  \n\nWindow window = alertDialog.getWindow();  \nwindow.setContentView(R.layout.dialog_main_info);  \n\nTextView tv_title = (TextView) window.findViewById(R.id.tv_dialog_title);  \ntv_title.setText(详细信息);  \nTextView tv_message = (TextView) window.findViewById(R.id.tv_dialog_message);  \ntv_message.setText(info);\n\n")])])]),i("p",[t._v("调用方式二：使用AlertDialog.Builder中的setView方法")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);\nView view = View.inflate(getActivity(), R.layout.custom_dialog, null);\nbuilder.setView(view);\nbuilder.setCancelable(true);\n\nTextView title= (TextView) view.findViewById(R.id.title);//设置标题\nEditText input_edt= (EditText) view.findViewById(R.id.dialog_edit);//输入内容\nButton btn_cancel=(Button)view.findViewById(R.id.btn_cancel);//取消按钮\nButton btn_comfirm=(Button)view.findViewById(R.id.btn_comfirm);//确定按钮\n\n//取消或确定按钮监听事件处理\nAlertDialog dialog = builder.create();\ndialog.show();  \n")])])]),i("h3",{attrs:{id:"andorid自定义view"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#andorid自定义view"}},[t._v("#")]),t._v(" Andorid自定义View")]),t._v(" "),i("p",[t._v("自定义View的实现方式有以下几种")]),t._v(" "),i("table",[i("thead",[i("tr",[i("th",[t._v("类型")]),t._v(" "),i("th",[t._v("定义")])])]),t._v(" "),i("tbody",[i("tr",[i("td",[t._v("自定义组合控件")]),t._v(" "),i("td",[t._v("多个控件组合成为一个新的控件，方便多处复用")])]),t._v(" "),i("tr",[i("td",[t._v("继承系统View控件")]),t._v(" "),i("td",[t._v("继承自TextView等系统控件，在系统控件的基础功能上进行扩展")])]),t._v(" "),i("tr",[i("td",[t._v("继承View")]),t._v(" "),i("td",[t._v("不复用系统控件逻辑，继承View进行功能定义")])]),t._v(" "),i("tr",[i("td",[t._v("继承系统ViewGroup")]),t._v(" "),i("td",[t._v("继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展")])]),t._v(" "),i("tr",[i("td",[t._v("继承ViewViewGroup")]),t._v(" "),i("td",[t._v("不复用系统控件逻辑，继承ViewGroup进行功能定义")])])])]),t._v(" "),i("p",[t._v("1.2 View绘制流程\nView的绘制基本由measure()、layout()、draw()这个三个函数完成\n函数\t作用\t相关方法\nmeasure()\t测量View的宽高\tmeasure(),setMeasuredDimension(),onMeasure()\nlayout()\t计算当前View以及子View的位置\tlayout(),onLayout(),setFrame()\ndraw()\t视图的绘制工作\tdraw(),onDraw()")]),t._v(" "),i("p",[t._v("1.5 自定义属性\nAndroid系统的控件以android开头的都是系统自带的属性。为了方便配置自定义View的属性，我们也可以自定义属性值。\nAndroid自定义属性可分为以下几步:")]),t._v(" "),i("p",[t._v("自定义一个View\n编写values/attrs.xml，在其中编写styleable和item等标签元素\n在布局文件中View使用自定义的属性（注意namespace）\n在View的构造方法中通过TypedArray获取")]),t._v(" "),i("p",[t._v("监听点击回调事件：\n1.定义接口和click等方法\n2.自定义view在特定场景调用接口click方法\n3.调用方实现接口")]),t._v(" "),i("h3",{attrs:{id:"事件分发机制"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#事件分发机制"}},[t._v("#")]),t._v(" 事件分发机制")]),t._v(" "),i("ul",[i("li",[t._v("对于一个根ViewGroup来说,发生点击事件首先调用dispatchTouchEvent")]),t._v(" "),i("li",[t._v("如果这个ViewGroup的onIterceptTouchEvent返回true就表示它要拦截当前事件,接着这个ViewGroup的onTouchEvent就会被调用.如果onIterceptTouchEvent返回false,那么就会继续向下调用子View的dispatchTouchEvent方法")]),t._v(" "),i("li",[t._v("当一个View需要处理事件的时候,如果它没有设置onTouchListener,那么直接调用onTouchEvent.如果设置了Listenter 那么就要看Listener的onTouch方法返回值.为true就不调,为false就调onTouchEvent")]),t._v(" "),i("li",[t._v("View的默认实现会在onTouchEvent里面把touch事件解析成Click之类的事件")]),t._v(" "),i("li",[t._v("点击事件传递顺序 Activity -> Window -> View")]),t._v(" "),i("li",[t._v("一旦一个元素拦截了某事件,那么一个事件序列里面后续的Move,Down事件都会交给它处理.并且它的onInterceptTouchEvent不会再调用")]),t._v(" "),i("li",[t._v("View的onTouchEvent默认都会消耗事件,除非它的clickable和longClickable都是false(不可点击),但是enable属性不会影响")])]),t._v(" "),i("h3",{attrs:{id:"java和kotlin混用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java和kotlin混用"}},[t._v("#")]),t._v(" java和kotlin混用")]),t._v(" "),i("p",[t._v("Android Studio添加Kotlin插件")]),t._v(" "),i("p",[t._v("项目根目录-引入依赖插件")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("buildscript {\n    ... \n    dependencies {\n        //gradle插件\n        classpath 'com.android.tools.build:gradle:4.2.2'\n        //kotlin插件\n        //classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:2.0.0'\n        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.0'\n    }\n}\n")])])]),i("p",[t._v("app目录-应用插件：kotlin-android")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("apply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\napply plugin: 'kotlin-parcelize'\n")])])]),i("p",[t._v("app引入-kotlin支持：")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("    //    implementation 'androidx.core:core-ktx:1.10.1'    //需要compilersdk到33\n    //    implementation \"org.jetbrains.kotlin:kotlin-stdlib:1.8.0\" //支持到kotlin1.8\nimplementation 'androidx.core:core-ktx:1.3.2'\nimplementation \"org.jetbrains.kotlin:kotlin-stdlib:1.8.0\"\n\napp中指定jdk版本\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n")])])]),i("p",[t._v("在 kotlin 1.8.0 之前，kotlin 的标准库 kotlin-stdlib 的 jvmTarget 是 Java 1.6，但是如果程序的 jvmTarget 是 1.7 或 1.8，则可以手动添加 kotlin-stdlib-jdk7 或 kotlin-stdlib-jdk8 来使用 kotin 对相关 Java 版本提供的 API\n在 kotlin 1.8.0 中 kotlin 标准库的 jvmTarget 修改为了 1.8（kotlinc 的 jvmTarget 默认为 1.8，支持到 18），且将 kotlin-stdlib-jdk7 和 kotlin-stdlib-jdk8 中的代码也打包到了 kotlin-stdlib 中，同时将 kotlin-stdlib-jdk7:1.8.0 和 kotlin-stdlib-jdk8:1.8.0 及之后的版本中的 sourceSets 置为了空，而是仅仅将 kotlin-stdlib 作为其依赖进行传递，以保证兼容。\n因此在 Kotlin1.8+ 中只需添加 kotlin-stdlib 的依赖即可，不再需要手动添加 kotlin-stdlib-jdk7 或 kotlin-stdlib-jdk8 的依赖。")]),t._v(" "),i("p",[t._v("添加kotlin代码")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('// Kotlin 文件中的代码\nfun helloWorld() {\n    println("Hello, World!")\n}\n')])])]),i("p",[t._v("添加java支持(貌似没啥用)")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("android {\n    sourceSets {\n        main.java.srcDirs += 'src/main/kotlin'\n    }\n}\n")])])]),i("p",[t._v("java调用kotlin代码")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("// Java 文件中的代码\npublic class Main {\n    public static void main(String[] args) {\n        MyKotlinFileKt.helloWorld();\n    }\n}\n")])])]),i("h3",{attrs:{id:"recyclebin机制"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#recyclebin机制"}},[t._v("#")]),t._v(" RecycleBin机制")]),t._v(" "),i("p",[t._v("RecycleBin机制是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。RecycleBin是AbsListView的一个内部类。")]),t._v(" "),i("ul",[i("li",[t._v("RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews中。")]),t._v(" "),i("li",[t._v("mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的时候将会返回null，所以mActiveViews不能被重复利用。")]),t._v(" "),i("li",[t._v("addScrapView()用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候（比如滚动出了屏幕）就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapV")]),t._v(" "),i("li",[t._v("iews和mCurrentScrap这两个List来存储废弃View。")]),t._v(" "),i("li",[t._v("getScrapView 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。")]),t._v(" "),i("li",[t._v("我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。")])]),t._v(" "),i("p",[t._v("View的流程分三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。")])])}),[],!1,null,null,null);i.default=n.exports}}]);