(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{241:function(t,e,a){t.exports=a.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(t,e,a){t.exports=a.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(t,e,a){t.exports=a.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},342:function(t,e,a){"use strict";a.r(e);var n=a(14),s=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_0-1learning"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[t._v("#")]),t._v(" 0-1Learning")]),t._v(" "),e("p",[e("img",{attrs:{src:a(241),alt:"alt text",title:"公众号"}}),t._v(" "),e("img",{attrs:{src:a(242),alt:"alt text",title:"学习"}}),t._v(" "),e("img",{attrs:{src:a(243),alt:"alt text",title:"微信"}})]),t._v(" "),e("h2",{attrs:{id:"组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),e("h3",{attrs:{id:"组件化应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件化应用"}},[t._v("#")]),t._v(" 组件化应用")]),t._v(" "),e("p",[t._v("组件是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。\n在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。")]),t._v(" "),e("h3",{attrs:{id:"注册组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注册组件"}},[t._v("#")]),t._v(" 注册组件")]),t._v(" "),e("p",[t._v("若想在一个组件中使用另一个组件，就必须先在 Vue 中注册组件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 定义名为 todo-item 的新组件\nVue.component('todo-item', {\n  template: '<li>这是个待办项</li>'\n})\n\n// 定义一个名为 button-counter 的新组件\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\n")])])]),e("ul",[e("li",[e("p",[t._v("组件名大小写"),e("br"),t._v("\n使用 kebab-case\nVue.component('my-component-name', { /* ... "),e("em",[t._v("/ })\n使用 PascalCase\nVue.component('MyComponentName', { /")]),t._v(" ... */ })")])]),t._v(" "),e("li",[e("p",[t._v("全局注册和局部注册"),e("br"),t._v("\n全局注册：Vue.component('component-a', { /* ... "),e("em",[t._v("/ })    //注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中\n局部注册：var ComponentA = { /")]),t._v(" ... */ }             //局部注册的组件在其子组件中不可用")])])]),t._v(" "),e("p",[t._v("注册组件示例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var ComponentA = { /* ... */ }\n\nvar ComponentB = {\n  components: {\n    'component-a': ComponentA\n  },\n  // ...\n}\n\n或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：\nimport ComponentA from './ComponentA'\nimport ComponentC from './ComponentC'\n\nexport default {\n  components: {\n    ComponentA,\n    ComponentC\n  },\n  // ...\n}\n")])])]),e("p",[t._v("在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<div id="app">\n  <app-nav></app-nav>   \x3c!-- 导航组件 --\x3e\n  <app-view>\n    <app-sidebar></app-sidebar> \x3c!-- 菜单组件 --\x3e\n    <app-content></app-content> \x3c!-- 内容组件 --\x3e\n  </app-view>\n</div>\n')])])]),e("h3",{attrs:{id:"组件复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件复用"}},[t._v("#")]),t._v(" 组件复用")]),t._v(" "),e("p",[t._v("你可以将组件进行任意次数的复用：")]),t._v(" "),e("div",{attrs:{id:"components-demo"}},[e("button-counter"),t._v(" "),e("button-counter"),t._v(" "),e("button-counter")],1),t._v(" "),e("h3",{attrs:{id:"组件data响应式数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件data响应式数据"}},[t._v("#")]),t._v(" 组件data响应式数据")]),t._v(" "),e("p",[t._v("data 必须是一个函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("当我们定义这个 <button-counter> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：\n\ndata: {\n  count: 0\n}\n取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：\n\ndata: function () {\n  return {\n    count: 0\n  }\n}\n")])])]),e("p",[t._v("当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。\n当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 我们的数据对象\nvar data = { a: 1 }\n\n// 该对象被加入到一个 Vue 实例中\nvar vm = new Vue({\n  data: data\n})\n\n// 获得这个实例上的 property\n// 返回源数据中对应的字段\nvm.a == data.a // => true\n\n// 设置 property 也会影响到原始数据\nvm.a = 2\ndata.a // => 2\n")])])]),e("p",[t._v("当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，将不会触发任何视图的更新")]),t._v(" "),e("p",[t._v("除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newValue, oldValue) {\n  // 这个回调将在 `vm.a` 改变后调用\n})\n")])])]),e("h3",{attrs:{id:"与自定义元素的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与自定义元素的关系"}},[t._v("#")]),t._v(" 与自定义元素的关系")]),t._v(" "),e("p",[t._v("Vue 组件非常类似于自定义元素——它是 Web 组件规范的一部分，这是因为 Vue 的组件语法部分参考了该规范。")]),t._v(" "),e("p",[t._v("例如 Vue 组件实现了 Slot API 与 is attribute。但是，还是有几个关键差别：")]),t._v(" "),e("ol",[e("li",[t._v("Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。")]),t._v(" "),e("li",[t._v("Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。")])]),t._v(" "),e("p",[t._v("虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，依然有很好的互操作性。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。")]),t._v(" "),e("h3",{attrs:{id:"组件的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件的生命周期"}},[t._v("#")]),t._v(" 组件的生命周期")]),t._v(" "),e("p",[t._v("每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。\n同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n比如 created 钩子可以用来在一个实例被创建之后执行代码：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("new Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n")])])]),e("p",[t._v("也有一些其它的钩子，在实例生命周期的不同阶段被调用，如init、created、 mounted、updated 和 destroyed等。\n生命周期钩子的 this 上下文指向调用它的 Vue 实例。")]),t._v(" "),e("h3",{attrs:{id:"计算属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[t._v("#")]),t._v(" 计算属性")]),t._v(" "),e("p",[t._v("计算属性类似提前申明一个函数，但跟普通函数不同的是：计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值")]),t._v(" "),e("p",[t._v("示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n")])])]),e("p",[t._v("Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。\n而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。")]),t._v(" "),e("h3",{attrs:{id:"侦听属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#侦听属性"}},[t._v("#")]),t._v(" 侦听属性")]),t._v(" "),e("p",[t._v("侦听属性：当你有一些数据需要随着其它数据变动而变动时，可以用到 watch，当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。")]),t._v(" "),e("p",[t._v("例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<div id=\"demo\">{{ fullName }}</div>\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    // 如果 `firstName` 发生改变，这个函数就会运行\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n")])])]),e("h3",{attrs:{id:"通过-prop-向子组件传递数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过-prop-向子组件传递数据"}},[t._v("#")]),t._v(" 通过 Prop 向子组件传递数据")]),t._v(" "),e("p",[t._v("Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。\nProp一般应用在父子组件嵌套使用上，子组件定义Prop名称，父组件传递数据。")]),t._v(" "),e("p",[t._v("HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。\ncamelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Vue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n\n\x3c!-- 在 HTML 中是 kebab-case 的 --\x3e\n<blog-post post-title=\"hello!\"></blog-post>\n\n传递动态 Prop\n\x3c!-- 动态赋予一个变量的值 --\x3e\n<blog-post v-bind:title=\"post.title\"></blog-post>\n")])])]),e("p",[t._v("prop类型\nprop不仅仅可以是字符串，还可以是对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("props: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n")])])]),e("h3",{attrs:{id:"组件单向数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件单向数据流"}},[t._v("#")]),t._v(" 组件单向数据流")]),t._v(" "),e("p",[t._v("所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：\n\nprops: ['initialCounter'],\ndata: function () {\n  return {\n    counter: this.initialCounter\n  }\n}\n")])])]),e("h3",{attrs:{id:"prop-验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prop-验证"}},[t._v("#")]),t._v(" Prop 验证")]),t._v(" "),e("p",[t._v("我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Vue.component('my-component', {\n  props: {\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 带有默认值的对象\n    propE: {\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n")])])]),e("h3",{attrs:{id:"自定义事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义事件"}},[t._v("#")]),t._v(" 自定义事件")]),t._v(" "),e("p",[t._v("事件名\n不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：")]),t._v(" "),e("p",[t._v("this.$emit('myEvent')\n则监听这个名字的 kebab-case 版本是不会有任何效果的：")]),t._v(" "),e("my-component",{on:{"my-event":t.doSomething}})],1)}),[],!1,null,null,null);e.default=s.exports}}]);