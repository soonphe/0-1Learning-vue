(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{241:function(v,_,t){v.exports=t.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(v,_,t){v.exports=t.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(v,_,t){v.exports=t.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},362:function(v,_,t){"use strict";t.r(_);var a=t(14),l=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_0-1learning"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[v._v("#")]),v._v(" 0-1Learning")]),v._v(" "),_("p",[_("img",{attrs:{src:t(241),alt:"alt text",title:"公众号"}}),v._v(" "),_("img",{attrs:{src:t(242),alt:"alt text",title:"学习"}}),v._v(" "),_("img",{attrs:{src:t(243),alt:"alt text",title:"微信"}})]),v._v(" "),_("h2",{attrs:{id:"面对对象的高级特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面对对象的高级特性"}},[v._v("#")]),v._v(" 面对对象的高级特性")]),v._v(" "),_("h3",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("面向对象OOP是基于面向过程而言，面向对象简单来说就是将功能封装到对象（数据和操作结合）里，我们面向对象，让对象去完成这些功能。\n万物皆对象。")])]),v._v(" "),_("li",[_("p",[v._v("（在我们程序员眼中，一切皆对象）")])]),v._v(" "),_("li",[_("p",[v._v("理解面向对象，经典案例：把大象塞进冰箱")]),v._v(" "),_("ol",[_("li",[v._v("面向过程的做法：1.打开冰箱门 2.把大象塞进去 3.关闭冰箱门\n当有两个不同的人用不同的方法实现这样的步骤，我们需要为不同的人量身定做不同解决事情的方法。")]),v._v(" "),_("li",[v._v("面向对象，找个对象帮你做事\n我们把冰箱作为对象，1.冰箱门可以被打开 2.大象可以被塞进去 3.冰箱门可以被关闭（面向对象写出通用的方法，屏蔽了所有人的差异）")])])])]),v._v(" "),_("h3",{attrs:{id:"要点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#要点"}},[v._v("#")]),v._v(" 要点")]),v._v(" "),_("ul",[_("li",[v._v("static的含义")]),v._v(" "),_("li",[v._v("继承的规则")]),v._v(" "),_("li",[v._v("子类实例化的过程")]),v._v(" "),_("li",[v._v("方法的覆盖")]),v._v(" "),_("li",[v._v("final关键字")]),v._v(" "),_("li",[v._v("抽象类的特性")]),v._v(" "),_("li",[v._v("接口的规范")]),v._v(" "),_("li",[v._v("数据类型的转换")]),v._v(" "),_("li",[v._v("包和访问权限修饰符")]),v._v(" "),_("li",[v._v("包装类和内部类")])]),v._v(" "),_("h3",{attrs:{id:"静态修饰符static"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态修饰符static"}},[v._v("#")]),v._v(" 静态修饰符static")]),v._v(" "),_("ul",[_("li",[v._v("static可以修饰的元素\n"),_("ul",[_("li",[v._v("属性 – 共享")]),v._v(" "),_("li",[v._v("方法 – 访问的方式")]),v._v(" "),_("li",[v._v("块 – 执行的时机")]),v._v(" "),_("li",[v._v("只能修饰类成员，不能修饰局部变量。")])])]),v._v(" "),_("li",[v._v("需要注意的问题：\n"),_("ul",[_("li",[v._v("静态方法可以直接访问静态变量，如要访问非静态变量必 须先实例化。")]),v._v(" "),_("li",[v._v("静态方法中不能this。")]),v._v(" "),_("li",[v._v("静态方法不能被非静态方法覆盖。")])])])]),v._v(" "),_("h3",{attrs:{id:"静态属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态属性"}},[v._v("#")]),v._v(" 静态属性")]),v._v(" "),_("ul",[_("li",[v._v("所有对象共享\n"),_("ul",[_("li",[v._v("也称为类变量")])])]),v._v(" "),_("li",[v._v("两种方式访问：\n"),_("ul",[_("li",[v._v("类名.属性；")]),v._v(" "),_("li",[v._v("对象名.属性")])])])]),v._v(" "),_("h3",{attrs:{id:"静态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[v._v("#")]),v._v(" 静态方法")]),v._v(" "),_("ul",[_("li",[v._v("不需要实例化，可以直接访问；\n"),_("ul",[_("li",[v._v("也称为类方法")])])]),v._v(" "),_("li",[v._v("两种方式访问：\n"),_("ul",[_("li",[v._v("直接访问：类名.方法名()；")]),v._v(" "),_("li",[v._v("实例化后访问：对象名.方法名()；")])])]),v._v(" "),_("li",[v._v("作用：\n"),_("ul",[_("li",[v._v("简化方法的使用；")]),v._v(" "),_("li",[v._v("便于访问静态属性；")])])]),v._v(" "),_("li",[v._v("限制：\n"),_("ul",[_("li",[v._v("静态方法只能直接访问静态成员。静态方法中不能this；")]),v._v(" "),_("li",[v._v("静态方法不能被非静态方法覆盖；")])])])]),v._v(" "),_("h3",{attrs:{id:"特殊的静态方法main"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特殊的静态方法main"}},[v._v("#")]),v._v(" 特殊的静态方法main")]),v._v(" "),_("ul",[_("li",[v._v("必须public权限修饰符")]),v._v(" "),_("li",[v._v("必须static静态修饰符")]),v._v(" "),_("li",[v._v("必须返回空值void")]),v._v(" "),_("li",[v._v("main函数名不可改变")]),v._v(" "),_("li",[v._v("String[] args命令行参数")])]),v._v(" "),_("h3",{attrs:{id:"变量初始化的顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量初始化的顺序"}},[v._v("#")]),v._v(" 变量初始化的顺序")]),v._v(" "),_("ol",[_("li",[v._v("隐式赋予变量默认值；")]),v._v(" "),_("li",[v._v("显式赋予初始值；")]),v._v(" "),_("li",[v._v("构造方法体赋予新值；")])]),v._v(" "),_("h3",{attrs:{id:"程序块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序块"}},[v._v("#")]),v._v(" 程序块")]),v._v(" "),_("ul",[_("li",[v._v("静态程序块")]),v._v(" "),_("li",[v._v("非静态程序块")])]),v._v(" "),_("h3",{attrs:{id:"类的继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类的继承"}},[v._v("#")]),v._v(" 类的继承")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("格式：修饰符 class 子类名 extends 父类名")])]),v._v(" "),_("li",[_("p",[v._v("Java中只能单继承，也就是说每个类只能有一个父类。")])]),v._v(" "),_("li",[_("p",[v._v("父类的别名：")]),v._v(" "),_("ul",[_("li",[v._v("基类BaseClass")]),v._v(" "),_("li",[v._v("超类SuperClass")])])]),v._v(" "),_("li",[_("p",[v._v("子类的别名：")]),v._v(" "),_("ul",[_("li",[v._v("衍生类")]),v._v(" "),_("li",[v._v("Child Class")]),v._v(" "),_("li",[v._v("Derived Class")])])])]),v._v(" "),_("h3",{attrs:{id:"类继承的规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类继承的规则"}},[v._v("#")]),v._v(" 类继承的规则")]),v._v(" "),_("ul",[_("li",[v._v("子类继承父类的所有属性和所有方法；")]),v._v(" "),_("li",[v._v("但是构造器不继承；")])]),v._v(" "),_("h3",{attrs:{id:"子类实例化过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#子类实例化过程"}},[v._v("#")]),v._v(" 子类实例化过程")]),v._v(" "),_("ul",[_("li",[v._v("子类实例化是先实例化其父类，然后实例化子类。")]),v._v(" "),_("li",[v._v("要先调用父类的构造器，父类构造器运行完毕，才调用子类的\n构造器。")]),v._v(" "),_("li",[v._v("如果实例化类D，说出构造器执行的顺序。")])]),v._v(" "),_("h3",{attrs:{id:"super和this关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#super和this关键字"}},[v._v("#")]),v._v(" super和this关键字")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("super()")]),v._v(" "),_("ul",[_("li",[v._v("指向父类的引用。")]),v._v(" "),_("li",[v._v("作用：调用父类的构造器")]),v._v(" "),_("li",[v._v("只能出现在子类的构造器中，且必须是第一行")]),v._v(" "),_("li",[v._v("super()中的参数，决定了调用父类哪个构造器")]),v._v(" "),_("li",[v._v("如果子类构造器中没有出现super，那么默认super()，即调用父类的空构造器。")])])]),v._v(" "),_("li",[_("p",[v._v("this()")]),v._v(" "),_("ul",[_("li",[v._v("指向本类的引用。")]),v._v(" "),_("li",[v._v("作用：调用本类的构造器")]),v._v(" "),_("li",[v._v("只能写在构造器的第一行")])])]),v._v(" "),_("li",[_("p",[v._v("在同一个构造器中super()和this()不能同时出现")])])]),v._v(" "),_("h3",{attrs:{id:"方法的覆盖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法的覆盖"}},[v._v("#")]),v._v(" 方法的覆盖")]),v._v(" "),_("ul",[_("li",[v._v("所谓 “覆盖(override)” 是在声明子类的成员方法时，其名称和参数都与父类的成员方法的名称和参数一样，在面向对象的程序设计中称为方法的覆盖。")]),v._v(" "),_("li",[v._v("规则")])]),v._v(" "),_("ol",[_("li",[v._v("在父子类之间继承时发生")]),v._v(" "),_("li",[v._v("多个方法的名称相同")]),v._v(" "),_("li",[v._v("返回值类型必须相同")]),v._v(" "),_("li",[v._v("每个方法参数数量和参数类型和顺序相同")]),v._v(" "),_("li",[v._v("权限修饰符要求：子类方法的要不小于父类方法的")]),v._v(" "),_("li",[v._v("子类方法只能抛出父类方法异常或其异常的子类。")]),v._v(" "),_("li",[v._v("方法覆盖如下例所示：\n"),_("ul",[_("li",[v._v("父类方法：protected void getArea( int w, int h) throws IOException;")]),v._v(" "),_("li",[v._v("子类方法：public void getArea( int x, int y) throws FileNotFoundException;")])])])]),v._v(" "),_("h3",{attrs:{id:"关键字final"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键字final"}},[v._v("#")]),v._v(" 关键字final")]),v._v(" "),_("ul",[_("li",[v._v("final可以修饰的元素：\n"),_("ul",[_("li",[v._v("变量(属性和局部变量和形参)：不能被重新赋值")])])]),v._v(" "),_("li",[v._v("在声明的同时赋值\n"),_("ul",[_("li",[v._v("方法：不能被覆盖，即不能修改。\n类：不能被继承\n注：* final类型的属性比较特殊，可以在声明的同时赋值，还可 以在构造器中赋值，在其他的方法中不能够赋值。")])])])]),v._v(" "),_("h3",{attrs:{id:"常量定义的一般格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常量定义的一般格式"}},[v._v("#")]),v._v(" 常量定义的一般格式")]),v._v(" "),_("ul",[_("li",[v._v("常量一般定义成下面的形式：\n"),_("ul",[_("li",[v._v("public static final double PI=3.14;")])])]),v._v(" "),_("li",[v._v("首先：\n"),_("ul",[_("li",[v._v("一般把它设置为静态static，多个实例共享该常量，没有必 要每个对象保存一份；")])])]),v._v(" "),_("li",[v._v("其次：\n"),_("ul",[_("li",[v._v("设置为final类型，赋值以后不能再改变；")])])]),v._v(" "),_("li",[v._v("第三：\n"),_("ul",[_("li",[v._v("注意遵守常量命名规范，所有字母大写，单词之间使用下 划线，如MAX_VALUES。")])])])]),v._v(" "),_("h3",{attrs:{id:"抽象方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象方法"}},[v._v("#")]),v._v(" 抽象方法")]),v._v(" "),_("ul",[_("li",[v._v("只有方法声明，没有方法实现的方法；")]),v._v(" "),_("li",[v._v("抽象方法用abstract声明，以“;”结尾。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("public abstract void getArea();\n")])])]),_("h3",{attrs:{id:"抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[v._v("#")]),v._v(" 抽象类")]),v._v(" "),_("ul",[_("li",[v._v("含有抽象方法的类必须声明为抽象类；")]),v._v(" "),_("li",[v._v("用abstract声明class")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("public abstract class Rectangle{ \n    public abstract void getArea();\n}\n\n")])])]),_("h3",{attrs:{id:"抽象类规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类规则"}},[v._v("#")]),v._v(" 抽象类规则")]),v._v(" "),_("ul",[_("li",[v._v("注意：\n"),_("ul",[_("li",[v._v("抽象类不能被实例化；")]),v._v(" "),_("li",[v._v("其包含的抽象方法必须在其子类中被实现，否则该子类只 能声明为abstract；")]),v._v(" "),_("li",[v._v("抽象方法不能为static；")])])]),v._v(" "),_("li",[v._v("在下列情况下，一个类必须声明为抽象类：\n"),_("ul",[_("li",[v._v("当一个类的一个或多个方法是抽象方法时；")]),v._v(" "),_("li",[v._v("当类是一个抽象类的子类，并且没有实现父类的所有抽象 方法，即只实现部分；")]),v._v(" "),_("li",[v._v("当一个类实现一个接口，并且不能为全部抽象方法都提供实现时；")])])]),v._v(" "),_("li",[v._v("本质")]),v._v(" "),_("li",[v._v("抽象类是抽象方法和非抽象方法的集合")]),v._v(" "),_("li",[v._v("特殊情况\n"),_("ul",[_("li",[v._v("全部是抽象方法")]),v._v(" "),_("li",[v._v("全部为非抽象方法")])])]),v._v(" "),_("li",[v._v("实际上是一套规范")])]),v._v(" "),_("h3",{attrs:{id:"接口interface"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口interface"}},[v._v("#")]),v._v(" 接口interface")]),v._v(" "),_("ul",[_("li",[v._v("接口不是一个类，不能实例化；")]),v._v(" "),_("li",[v._v("接口是常量和抽象方法的集合；")]),v._v(" "),_("li",[v._v("接口对类来说是一套规范，是一套行为协议；")]),v._v(" "),_("li",[v._v("定义格式如下：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("public interface\tMyInterface\n{\ninterfaceBody\n}\n")])])]),_("h3",{attrs:{id:"类实现接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类实现接口"}},[v._v("#")]),v._v(" 类实现接口")]),v._v(" "),_("ul",[_("li",[v._v("接口实质上就是一个常量和抽象方法的集合。为了使用一个接口，你要编写实现接口的类。")]),v._v(" "),_("li",[v._v("如果一个类要实现一个接口，那么这个类就必须实现接口中所有抽象方法。否则这个类只能声明为抽象。")]),v._v(" "),_("li",[v._v("格式如下：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("public class MyClass implements\tMyInterface{\n//实现接口中所有抽象方法\n}\n")])])]),_("h3",{attrs:{id:"接口的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口的特点"}},[v._v("#")]),v._v(" 接口的特点")]),v._v(" "),_("ul",[_("li",[v._v("接口使用interface关键字来定义，而不是class。")]),v._v(" "),_("li",[v._v("接口中定义的变量都是公共静态最终变量。")]),v._v(" "),_("li",[v._v("接口中没有自己的构造函数，而且接口中定义的方法全部都是 抽象方法，即只提供方法的定义，而没有提供方法的具体实现的语句。")]),v._v(" "),_("li",[v._v("接口采用多继承机制，而不像类一样采用单继承机制。")]),v._v(" "),_("li",[v._v("接口默认：\n"),_("ul",[_("li",[v._v("常量：public static final")]),v._v(" "),_("li",[v._v("抽象方法： public abstract")])])])]),v._v(" "),_("h3",{attrs:{id:"接口和抽象类的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类的区别"}},[v._v("#")]),v._v(" 接口和抽象类的区别")]),v._v(" "),_("ul",[_("li",[v._v("接口不能含有任何非抽象方法，而抽象类可以。")]),v._v(" "),_("li",[v._v("类可以实现许多接口，但只能有一个父类。")]),v._v(" "),_("li",[v._v("接口不是类分级结构的一部分，没有联系的类可以实现相同的接口。")])]),v._v(" "),_("h3",{attrs:{id:"接口种访问常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口种访问常量"}},[v._v("#")]),v._v(" 接口种访问常量")]),v._v(" "),_("ul",[_("li",[v._v("public static final int MAX_SPEED=100;")]),v._v(" "),_("li",[v._v("有三种方式：\n"),_("ul",[_("li",[v._v("对象名.MAX_SPEED")]),v._v(" "),_("li",[v._v("类名. MAX_SPEED")]),v._v(" "),_("li",[v._v("接口名. MAX_SPEED")])])])]),v._v(" "),_("h3",{attrs:{id:"引用数据类型的转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用数据类型的转换"}},[v._v("#")]),v._v(" 引用数据类型的转换")]),v._v(" "),_("ul",[_("li",[v._v("前提：具有继承关系")]),v._v(" "),_("li",[v._v("原则：子类就是父类")]),v._v(" "),_("li",[v._v("向上造型：子类转换为父类，自动转换；")]),v._v(" "),_("li",[v._v("向下造型：强制转换\n"),_("ul",[_("li",[v._v("曾经向上转换过的对象，才能再向下转换。")])])]),v._v(" "),_("li",[v._v("向上转换损失了子类新扩展的属性和方法")]),v._v(" "),_("li",[v._v("仅剩下父类中声明过的属性和方法")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("Person p = new Student(); \nStudent s = (Student)p;\n")])])]),_("h3",{attrs:{id:"instanceof运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#instanceof运算符"}},[v._v("#")]),v._v(" instanceof运算符")]),v._v(" "),_("ul",[_("li",[v._v("instanceof运算符的一般格式：\n"),_("ul",[_("li",[v._v("object instanceof class")]),v._v(" "),_("li",[v._v("object instanceof interface")]),v._v(" "),_("li",[v._v("返回值都是boolean")])])])]),v._v(" "),_("h3",{attrs:{id:"多态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("本质上遵守引用类型的转换规则")])]),v._v(" "),_("li",[_("p",[v._v("分为两种表现形式")]),v._v(" "),_("ul",[_("li",[v._v("赋值多态")]),v._v(" "),_("li",[v._v("传参多态（隐式的赋值多态）")])])]),v._v(" "),_("li",[_("p",[v._v("多态的机制")])]),v._v(" "),_("li",[_("p",[v._v("Override")])])]),v._v(" "),_("h3",{attrs:{id:"所有类的父类-object"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#所有类的父类-object"}},[v._v("#")]),v._v(" 所有类的父类 Object")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Object类是所有类的超类，在Object类中定义的方法，在所有 类中都可以使用。")])]),v._v(" "),_("li",[_("p",[v._v("一个类可以不是Object类的直接子类，但一定是Object类的子 类，Java中的每一个类都是从Object扩展来的。")])]),v._v(" "),_("li",[_("p",[v._v("Object是Java语言中唯一一个没有父类的类。")])]),v._v(" "),_("li",[_("p",[v._v("Object类常用方法：")]),v._v(" "),_("ul",[_("li",[v._v("public int hashCode()")])])]),v._v(" "),_("li",[_("p",[v._v("返回十六进制整数，唯一标识一个对象")]),v._v(" "),_("ul",[_("li",[v._v("public String toString()")])])]),v._v(" "),_("li",[_("p",[v._v("返回 类名@hashcode")]),v._v(" "),_("ul",[_("li",[v._v("public boolean equals(Object obj)")])])]),v._v(" "),_("li",[_("p",[v._v("比较两个对象引用的值是否相等（比较地址）")])])]),v._v(" "),_("h3",{attrs:{id:"equals-与-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#equals-与-的区别"}},[v._v("#")]),v._v(" equals()与==的区别")]),v._v(" "),_("ul",[_("li",[v._v("理解equals()方法和==运算符的区别是非常重要的。")]),v._v(" "),_("li",[v._v("equals()只能比较引用类型，==既能比较引用类型又能比较\n基本类型。")]),v._v(" "),_("li",[v._v("equals()方法从Object类继承\n"),_("ul",[_("li",[v._v("比较引用类型：两个变量是否指向同一个对象，或两个变量是否引用了相同的地址")]),v._v(" "),_("li",[v._v("但是包装类，string，File，Date例外，判断堆中所存的值或数据是否相等")]),v._v(" "),_("li",[v._v("一般都被子类方法覆盖，不再比较引用的值")])])]),v._v(" "),_("li",[v._v("==运算符\n"),_("ul",[_("li",[v._v("比较基本数据类型：相当于算术等号")]),v._v(" "),_("li",[v._v("比较引用数据类型：比较引用的值，两个变量是否指向同一个对象，或两个变量是否引用了相同的地址，不能被覆盖。")])])])]),v._v(" "),_("h3",{attrs:{id:"java种常用的包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java种常用的包"}},[v._v("#")]),v._v(" java种常用的包")]),v._v(" "),_("ul",[_("li",[v._v("java.lang\n"),_("ul",[_("li",[v._v("Java语言包，任何程序中，该包都被自动导入。")])])]),v._v(" "),_("li",[v._v("java.awt\n"),_("ul",[_("li",[v._v("图形用户界面包。")])])]),v._v(" "),_("li",[v._v("java.awt.event\n"),_("ul",[_("li",[v._v("图形用户界面事件处理包。")])])]),v._v(" "),_("li",[v._v("java.swing\n"),_("ul",[_("li",[v._v("跨平台轻量级组件包。")])])]),v._v(" "),_("li",[v._v("java.sql\n"),_("ul",[_("li",[v._v("数据库访问包。")])])]),v._v(" "),_("li",[v._v("java.io\n"),_("ul",[_("li",[v._v("这个包由对您的输入/输出操作有用的类组成。")])])]),v._v(" "),_("li",[v._v("java.util\n"),_("ul",[_("li",[v._v("该包提供了许多创建如：lists, calendar, date等所需要的类和接口。")])])]),v._v(" "),_("li",[v._v("java.net\n"),_("ul",[_("li",[v._v("该包提供了许多进行TCP/IP网络编程的类和接口。")])])])]),v._v(" "),_("h3",{attrs:{id:"用import导入包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用import导入包"}},[v._v("#")]),v._v(" 用import导入包")]),v._v(" "),_("ul",[_("li",[v._v("导入包中所有的类：import package_name.*;")]),v._v(" "),_("li",[v._v("依照下列语法导入单个类：import package_name.class_name;")]),v._v(" "),_("li",[v._v("导入网络包中所有的类：import java.net.*;")])]),v._v(" "),_("h3",{attrs:{id:"访问权限修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#访问权限修饰符"}},[v._v("#")]),v._v(" 访问权限修饰符")]),v._v(" "),_("ul",[_("li",[v._v("public > protected > friendly > private")]),v._v(" "),_("li",[v._v("封装")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("权限/位•置")]),v._v(" "),_("th",[v._v("private")]),v._v(" "),_("th",[v._v("friendly")]),v._v(" "),_("th",[v._v("protected")]),v._v(" "),_("th",[v._v("public")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("类内部")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")])]),v._v(" "),_("tr",[_("td",[v._v("同包无继承关系类")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")])]),v._v(" "),_("tr",[_("td",[v._v("同包子类")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")])]),v._v(" "),_("tr",[_("td",[v._v("不同包子类")]),v._v(" "),_("td"),v._v(" "),_("td"),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("√")])]),v._v(" "),_("tr",[_("td",[v._v("不同包无继承关系类")]),v._v(" "),_("td"),v._v(" "),_("td"),v._v(" "),_("td"),v._v(" "),_("td",[v._v("√")])])])]),v._v(" "),_("h3",{attrs:{id:"包装类wrapper"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包装类wrapper"}},[v._v("#")]),v._v(" 包装类wrapper")]),v._v(" "),_("ul",[_("li",[v._v("Everything is object.")]),v._v(" "),_("li",[v._v("Java编程语言不把基本数据类型看作对象。")]),v._v(" "),_("li",[v._v("Java 编程语言提供包装类来将基本数据类型看作对象。")]),v._v(" "),_("li",[v._v("基本数据类型：\nbyte char short int long float double boolean")]),v._v(" "),_("li",[v._v("引用数据类型：\nByte Character Short Integer Long Float Double Boolean")])]),v._v(" "),_("h4",{attrs:{id:"包装类的创建办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包装类的创建办法"}},[v._v("#")]),v._v(" 包装类的创建办法")]),v._v(" "),_("ul",[_("li",[v._v("基本数据类型通过构造器转换为包装类")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("int pInt = 500;\nInteger wInt = new Integer(pInt);\nInteger a=new Integer(3);\n")])])]),_("h4",{attrs:{id:"包装类的常用方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包装类的常用方法"}},[v._v("#")]),v._v(" 包装类的常用方法")]),v._v(" "),_("ul",[_("li",[v._v("primitive  wrapper\n"),_("ul",[_("li",[v._v("Contructor")])])]),v._v(" "),_("li",[v._v("String  wrapper\n"),_("ul",[_("li",[v._v("Contructor(除Character,注意Boolean)")]),v._v(" "),_("li",[v._v("static valueOf( String s) 静态有参数")])])]),v._v(" "),_("li",[v._v("wrapper  primitive\n"),_("ul",[_("li",[v._v("typeValue() 无参数")])])]),v._v(" "),_("li",[v._v("String  primitive\n"),_("ul",[_("li",[v._v("static parseType()")])])]),v._v(" "),_("li",[v._v("equals()")]),v._v(" "),_("li",[v._v("toString()")])]),v._v(" "),_("h3",{attrs:{id:"内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[v._v("#")]),v._v(" 内部类")]),v._v(" "),_("ul",[_("li",[v._v("内部类就是定义在另一个类内部的类。")]),v._v(" "),_("li",[v._v("内部类对于同一包中的其它类来说，内部类能够隐藏起来。")])]),v._v(" "),_("h4",{attrs:{id:"内部类与外部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内部类与外部类"}},[v._v("#")]),v._v(" 内部类与外部类")]),v._v(" "),_("ul",[_("li",[v._v("无需创建外部类的对象，即可从内部类访问外部类的变量和方法。")]),v._v(" "),_("li",[v._v("必须创建内部类的对象，否则无法从外部类访问内部类的变量和方法。")]),v._v(" "),_("li",[v._v("如果内部类中有和外部类同名的变量或方法，则内部类的变量和方法将获得比外部类的变量和方法更高的优先级。")]),v._v(" "),_("li",[v._v("不能定义static变量")])]),v._v(" "),_("h4",{attrs:{id:"从其他类访问内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从其他类访问内部类"}},[v._v("#")]),v._v(" 从其他类访问内部类")]),v._v(" "),_("ul",[_("li",[v._v("在Outer内访问Inner,只需如下:\n"),_("ul",[_("li",[v._v("Inner in=new Inner();")])])]),v._v(" "),_("li",[v._v("在Outer外访问Inner,必须如下:\n"),_("ul",[_("li",[v._v("Outer o = new Outer();\t//实例化外部类")]),v._v(" "),_("li",[v._v("Outer.Inner oi=o.new Inner(); //实例化内部类")])])])]),v._v(" "),_("h4",{attrs:{id:"内部类的权限修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内部类的权限修饰符"}},[v._v("#")]),v._v(" 内部类的权限修饰符")]),v._v(" "),_("ul",[_("li",[v._v("普通类的访问控制方式\n"),_("ul",[_("li",[v._v("friendly")]),v._v(" "),_("li",[v._v("public")])])]),v._v(" "),_("li",[v._v("内部类定义为\n"),_("ul",[_("li",[v._v("private")]),v._v(" "),_("li",[v._v("protected")]),v._v(" "),_("li",[v._v("public")]),v._v(" "),_("li",[v._v("friendly")])])])]),v._v(" "),_("h4",{attrs:{id:"静态内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态内部类"}},[v._v("#")]),v._v(" 静态内部类")]),v._v(" "),_("ul",[_("li",[v._v("Outer.Inner inn=new Outer.Inner();")]),v._v(" "),_("li",[v._v("非静态内部类不可以使用上面的方式")]),v._v(" "),_("li",[v._v("可以定义static变量")]),v._v(" "),_("li",[v._v("就相当于定义在外部的类。")])]),v._v(" "),_("h4",{attrs:{id:"局部内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#局部内部类"}},[v._v("#")]),v._v(" 局部内部类")]),v._v(" "),_("ul",[_("li",[v._v("Outer.Inner inn=new Outer.Inner();")]),v._v(" "),_("li",[v._v("非静态内部类不可以使用上面的方式")]),v._v(" "),_("li",[v._v("可以定义static变量")]),v._v(" "),_("li",[v._v("就相当于定义在外部的类。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("class A{ \n    int a;\n    public void method(){\n    }\n    class B{ }\n}\n\nclass A{\n    int a;\n    public void method( int c ){ int b=0;\n    class B{ }\n    }\n}\n\n")])])]),_("h4",{attrs:{id:"匿名内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#匿名内部类"}},[v._v("#")]),v._v(" 匿名内部类")]),v._v(" "),_("ul",[_("li",[v._v("匿名内部类：\n"),_("ul",[_("li",[v._v("顾名思义，匿名内部类就是没有类名的内部类.")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);