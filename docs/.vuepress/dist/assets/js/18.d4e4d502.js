(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{241:function(v,l,a){v.exports=a.p+"assets/img/luoxiaosheng.3e3f64f6.svg"},242:function(v,l,a){v.exports=a.p+"assets/img/luoxiaosheng_learning.c39ce245.svg"},243:function(v,l,a){v.exports=a.p+"assets/img/luoxiaosheng_wechat.8efd3324.svg"},310:function(v,l,a){v.exports=a.p+"assets/img/java_thread.20e7de1c.png"},311:function(v,l,a){v.exports=a.p+"assets/img/java_thread_method.e3d334df.png"},364:function(v,l,a){"use strict";a.r(l);var _=a(14),t=Object(_.a)({},(function(){var v=this,l=v._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"_0-1learning"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_0-1learning"}},[v._v("#")]),v._v(" 0-1Learning")]),v._v(" "),l("p",[l("img",{attrs:{src:a(241),alt:"alt text",title:"公众号"}}),v._v(" "),l("img",{attrs:{src:a(242),alt:"alt text",title:"学习"}}),v._v(" "),l("img",{attrs:{src:a(243),alt:"alt text",title:"微信"}})]),v._v(" "),l("h2",{attrs:{id:"多线程编程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程编程"}},[v._v("#")]),v._v(" 多线程编程")]),v._v(" "),l("h3",{attrs:{id:"简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),l("p",[v._v("进程和线程")]),v._v(" "),l("p",[v._v("一个程序就是一个进程，而一个程序中的多个任务则被称为线程。")]),v._v(" "),l("p",[v._v("进程是表示资源分配的基本单位，线程是进程中执行运算的最小单位，亦是调度运行的基本单位。")]),v._v(" "),l("p",[v._v("进程才是资源分配的最小单位，线程是CPU分配的最小单位，线程所拥有的最重要的资源是：它拥有独立的CUP时间片。")]),v._v(" "),l("p",[v._v("一个进程中的所有线程共享进程中的全局变量，堆和环境字符串。但它拥有自己的栈（即存放局部变量的地方）。")]),v._v(" "),l("p",[v._v("​举个例子：")]),v._v(" "),l("p",[v._v("打开你的计算机上的任务管理器，会显示出当前机器的所有进程，QQ，360等，当QQ运行时，就有很多子任务在同时运行。比如，当你边打字发送表情，边好友视频时这些不同的功能都可以同时运行，其中每一项任务都可以理解成“线程”在工作。")]),v._v(" "),l("h3",{attrs:{id:"要点"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#要点"}},[v._v("#")]),v._v(" 要点")]),v._v(" "),l("ul",[l("li",[v._v("多线程简介\n"),l("ul",[l("li",[v._v("多线程模型")])])]),v._v(" "),l("li",[v._v("多线程实现的两种方式\n"),l("ul",[l("li",[v._v("实现Runnable接口")]),v._v(" "),l("li",[v._v("继承Thread类")])])]),v._v(" "),l("li",[v._v("线程的属性和控制\n"),l("ul",[l("li",[v._v("线程状态及其生命周期")]),v._v(" "),l("li",[v._v("线程类的主要方法")]),v._v(" "),l("li",[v._v("休眠和中断")])])]),v._v(" "),l("li",[v._v("多线程同步/通信问题\n"),l("ul",[l("li",[v._v("线程同步，锁和死锁")])])])]),v._v(" "),l("h3",{attrs:{id:"多线程简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程简介"}},[v._v("#")]),v._v(" 多线程简介")]),v._v(" "),l("h4",{attrs:{id:"基本概念"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[v._v("#")]),v._v(" 基本概念")]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[v._v("* 进程计算机在执行的程序的实体\n* e.g. 一个.class文件 一个.exe文件 ……\n* 线程 一个程序内部的顺序控制流\n* 一个进程中可以包含 一个或多个线程，一个线程就是一个程序内部的一条执行线索\n")])])]),l("h4",{attrs:{id:"进程-线程区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#进程-线程区别"}},[v._v("#")]),v._v(" 进程/线程区别")]),v._v(" "),l("ul",[l("li",[v._v("进程和线程的区别\n"),l("ul",[l("li",[v._v("每个进程都有独立的代码和数据空间，进程的切换 会有很大的开销")]),v._v(" "),l("li",[v._v("同一类线程共享代码和数据空间，每个线程有独立 运行的栈和程序计数器，线程切换的开销小")])])]),v._v(" "),l("li",[v._v("多进程和多线程\n"),l("ul",[l("li",[v._v("多进程：在操作系统中能同时运行多个任务（程序）")]),v._v(" "),l("li",[v._v("多线程：在同一应用程序中有多个顺序流同时执行")])])])]),v._v(" "),l("h4",{attrs:{id:"多线程实现的两种方式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程实现的两种方式"}},[v._v("#")]),v._v(" 多线程实现的两种方式")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("多线程的实现\n(1)\t创建线程类\n* 继承Thread类\t或\n* 实现Runnable接口\n(2)\t通过Thread类构造器来创建线程对象\n* Thread( )\n* Thread(Runnable target)\n(3)\t通过start()方法激活线程对象")])]),v._v(" "),l("li",[l("p",[v._v("创建线程的两种方式 — 线程类")]),v._v(" "),l("ul",[l("li",[v._v("继承Thread类—— java.lang.Thread")]),v._v(" "),l("li",[v._v("实现Runnable接口 —— java.lang.Runnable")])])]),v._v(" "),l("li",[l("p",[v._v("run( )方法 — 线程运行体")]),v._v(" "),l("ul",[l("li",[v._v("要将一段代码（线程体）在一个新的线程上运行，该代码应该在一 个线程类的run( )函数中\n"),l("ul",[l("li",[v._v("写一个类implements Runnable接口，且必须覆盖Runnable接口中的run( )方法")]),v._v(" "),l("li",[v._v("写一个类extends Thread类，且必须重写Thread类的run( )方法")])])])])]),v._v(" "),l("li",[l("p",[v._v("继承Thread类")]),v._v(" "),l("ul",[l("li",[v._v("定义线程类继承Thread类")]),v._v(" "),l("li",[v._v("覆盖run( )方法public void run( )")])])])]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[v._v("public class ThreadDemo extends Thread{\n\n    public void run(){\n        //代码块\n    }\n}\npublic class TestThread{\n\n    public static void(string[] args){\n        ThreadDemo t = new ThreadDemo();\n        t.start;\n        //代码块\n    }\n    public void run(){\n        //代码块\n    }\n}\n//说明 run( ) 与 start( ): run是单线程运行，start是多线程执行\n")])])]),l("ul",[l("li",[v._v("实现Runnable接口\n"),l("ul",[l("li",[v._v("定义线程类实现\nRunnable接口\n线程共享同样的数据和代码")]),v._v(" "),l("li",[v._v("覆盖Runnable接口中的唯一的方法public void run( )")])])])]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[v._v("public class RunnableDemo implement Runnable{\n\n    public void run(){\n        //代码块\n    }\n}\n")])])]),l("ul",[l("li",[v._v("两种方式的比较\n"),l("ul",[l("li",[v._v("使用Runnable接口可以避免由于JAVA的单继承性带来的局限")]),v._v(" "),l("li",[v._v("适合多个相同的程序代码的线程去处理同一资源情况，把线程同 程序的代码、数据有效的分离\n"),l("ul",[l("li",[v._v("推荐使用实现Runnable")])])])])])]),v._v(" "),l("h3",{attrs:{id:"线程状态及其生命周期"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程状态及其生命周期"}},[v._v("#")]),v._v(" 线程状态及其生命周期")]),v._v(" "),l("ul",[l("li",[v._v("线程的状态及其生命周期\n"),l("ul",[l("li",[v._v("一个 Thread 对象在它的整个生存期中能以几种不同的状态存在\n"),l("img",{attrs:{src:a(310),alt:"alt text"}})])])]),v._v(" "),l("li",[v._v("start( ) — 方法使线程处于可以运行的状态，但不一定意味着该线程立即开始运行")])]),v._v(" "),l("h3",{attrs:{id:"线程类的主要方法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程类的主要方法"}},[v._v("#")]),v._v(" 线程类的主要方法")]),v._v(" "),l("ul",[l("li",[v._v("线程中的主要方法 —— java.lang.Thread\n"),l("img",{attrs:{src:a(311),alt:"alt text"}})])]),v._v(" "),l("h3",{attrs:{id:"线程的优先级"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的优先级"}},[v._v("#")]),v._v(" 线程的优先级")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("线程的优先级")]),v._v(" "),l("ul",[l("li",[v._v("Java提供一个线程调度器来监控程序中启动后进入就绪状态的所用线程，线程调度器按照线程的优先级来决定应调度哪个线程来执 行")])])]),v._v(" "),l("li",[l("p",[v._v("线程的优先级用数字表示，范围从1到10，一个线程缺省的优先级是5\n* Thread.MIN_PRIORITY = 1\n* Thread.NORM_PRIORITY = 5\n* Thread.MAX_PRIORITY = 10")])]),v._v(" "),l("li",[l("p",[v._v("线程优先级方法")]),v._v(" "),l("ul",[l("li",[v._v("getPriority( ) —— 确定线程的优先级")]),v._v(" "),l("li",[v._v("setPriority( ) ——\t设置线程的优先级")])])])]),v._v(" "),l("h3",{attrs:{id:"线程的休眠"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的休眠"}},[v._v("#")]),v._v(" 线程的休眠")]),v._v(" "),l("ul",[l("li",[v._v("线程的休眠\n"),l("ul",[l("li",[v._v("sleep( )\n"),l("ul",[l("li",[v._v("让线程中止一段时间的静态方法")]),v._v(" "),l("li",[v._v("Thread.sleep(long millis) — 暂时停止执行millis毫秒")]),v._v(" "),l("li",[v._v("在睡眠期满的瞬间，再次调用该线程不一定会恢复它的执行")])])]),v._v(" "),l("li",[v._v("join()\n"),l("ul",[l("li",[v._v("导致当前线程等待，直到调用这个 join 方法的线程终止")]),v._v(" "),l("li",[v._v("join( )\tjoin(long millis)\tjoin(long millis,int nanos)")])])]),v._v(" "),l("li",[v._v("yield()\n"),l("ul",[l("li",[v._v("为其他可运行的线程提供执行机会")]),v._v(" "),l("li",[v._v("静态方法 — Thread.yield( )")])])])])])]),v._v(" "),l("h3",{attrs:{id:"线程的中断"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的中断"}},[v._v("#")]),v._v(" 线程的中断")]),v._v(" "),l("ul",[l("li",[v._v("线程的终止\n"),l("ul",[l("li",[v._v("自动终止 — 一个线程完成执行后，不能再次运行")]),v._v(" "),l("li",[v._v("手动终止\n"),l("ul",[l("li",[v._v("stop( ) —— 已过时，基本不用")]),v._v(" "),l("li",[v._v("interrupt( ) —— 粗暴的终止方式")]),v._v(" "),l("li",[v._v("可通过使用一个标志指示 run 方法退出，从而终止线程—— 推荐使用")])])])])])]),v._v(" "),l("h3",{attrs:{id:"线程的高级操作"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的高级操作"}},[v._v("#")]),v._v(" 线程的高级操作")]),v._v(" "),l("ul",[l("li",[v._v("线程的高级操作\n"),l("ul",[l("li",[v._v("Object类中线程的相关方法：\n"),l("ul",[l("li",[v._v("void wait()：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法")]),v._v(" "),l("li",[v._v("void notify()：唤醒在此对象监视器上等待的单个线程。")]),v._v(" "),l("li",[v._v("void notifyAll()：唤醒在此对象监视器上等待的所有线程。")])])])])])]),v._v(" "),l("h3",{attrs:{id:"线程同步"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程同步"}},[v._v("#")]),v._v(" 线程同步")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("有时两个或多个线程可能会试图同时访问一个资源")]),v._v(" "),l("ul",[l("li",[v._v("例如，一个线程可能尝试从一个文件中读取数据，而另一个线程 则尝试在同一文件中修改数据")]),v._v(" "),l("li",[v._v("在此情况下，数据可能会变得不一致")])])]),v._v(" "),l("li",[l("p",[v._v("为了确保在任何时间点一个共享的资源只被一个线程使用，使用了“同步”")]),v._v(" "),l("ul",[l("li",[v._v("当一个线程运行到需要同步的语句后，CPU不去执行其他线程中的、可能影响当前线程中的下一句代码的执行结果的代码块，必须等 到下一句执行完后才能去执行其他线程中的相关代码块，这就是 线程同步")])])])]),v._v(" "),l("h3",{attrs:{id:"锁"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[v._v("#")]),v._v(" 锁")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("实现同步的两种方式")]),v._v(" "),l("ul",[l("li",[v._v("锁定方法"),l("br"),v._v("\nsynchronized void methodA() {\t}")]),v._v(" "),l("li",[v._v("锁定方法代码块"),l("br"),v._v("\nsynchronized (Object) {\n//要同步的语句\n}")])])]),v._v(" "),l("li",[l("p",[v._v("一旦一个包含锁定方法（用synchronized修饰）的线程被CPU调用，其 他线程就无法调用相同对象的锁定方法。当一个线程在一个锁定方法内部，  所有试图调用该方法的同实例的其他线程必须等待")]),v._v(" "),l("ul",[l("li",[v._v("注意事项：\n"),l("ul",[l("li",[v._v("受到synchronized保护的程序代码块和方法中，要访问的对象属性必须设定为private，因为如果不设定为private，那么就可 以用不同的方式来访问它，这样就达不到保护的效果了")])])])])]),v._v(" "),l("li",[l("p",[v._v("实现同步的两种方式—两种方式的优缺点")]),v._v(" "),l("ul",[l("li",[v._v("锁定方法\n"),l("ul",[l("li",[v._v("优点：可以显示的知道哪些方法是被锁定的")]),v._v(" "),l("li",[v._v("缺点：\n"),l("ul",[l("li",[v._v("方法中有些程序时不需要保护的，如果该方法执行会花很长时间，那么其他人就要花较多时间等待锁被归还；")]),v._v(" "),l("li",[v._v("只能取得自己对象的锁，有时候程序设计的需求，可能会需要取得其他对象的锁；")])])])])]),v._v(" "),l("li",[v._v("锁定代码块\n"),l("ul",[l("li",[v._v("优点：\n"),l("ul",[l("li",[v._v("可以针对某段程序代码锁定， 不需要浪费时间在别的")]),v._v(" "),l("li",[v._v("程序代码上,可以取得不同对象的锁")])])]),v._v(" "),l("li",[v._v("缺点：方法中有些程序时不需要保护的，如果该方法执行会花很长时间，那么其他人就要花较多时间等待锁被归还；\n只能取得自己对象的锁，有时候程序设计的需求，可能会需要取得其他对象的锁；")])])])])])]),v._v(" "),l("h3",{attrs:{id:"死锁"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),l("ul",[l("li",[v._v("死锁\n"),l("ul",[l("li",[v._v("乱用synchronized可能会造成系统打死锁(Dead Lock)的状况！")]),v._v(" "),l("li",[v._v("锁的归还几种方式：\n"),l("ul",[l("li",[v._v("基本上执行完锁定的程序代码后，锁就会自动归还；")]),v._v(" "),l("li",[v._v("用break语句跳出锁定的语句块，不过这对于写在方法声明的synchronized没有作用；")]),v._v(" "),l("li",[v._v("遇到return语句；")]),v._v(" "),l("li",[v._v("遇到了异常；")])])])])])])])}),[],!1,null,null,null);l.default=t.exports}}]);